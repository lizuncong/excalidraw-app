## 元素绘制
使用canvas绘制元素，使用roughjs绘制手绘风格的元素

## 数据模型
每种图形元素都有对应的数据模型设计，包含哪些字段可以完美承载所有图形元素的表示，元素的位置、大小信息、颜色、背景色等等，其中还有用于解决多人协作时技术难点的字段，比如verson、versionNonce

## 流程
drawing -> element -> render(roughjs) -> scene
- 数据驱动页面更新
- actionManager管理全局的行为，比如撤销重做等
## 元素绘制
Excalidraw借助浏览器基础鼠标事件：onPointerUp、onPointerDown、onPointerMove 记录用户的行为轨迹。比如如果在工具栏选择矩形，在画布内第一次 pointerDown 事件代表绘制开始（标记起始点），后面的 pointerMove 事件改变矩形宽高（当前点位与起始点差值），pointerMove 事件代表绘制完成。其它的图形绘制与此类似。

## 撤销/重做
Excalidraw使用一个History对象保存操作历史，其中用一个数组栈stateHistory保存用户每一次修改数据时的一个临时状态，然后按撤销时出栈最近的状态，用数据状态恢复界面状态。出栈的状态会被保存到另外的数组redoStack里面，重做时又从这个数组里面出栈

## 多人协作
- 多人协作通过共享ExcalidrawElement数据模型数组实现，通过socket.io实现状态同步
- 采用端到端加密技术，密钥保存在浏览器链接的hash上，服务器解密不了数据内容
- 多人协作最主要的几个难点涉及多人新增元素、删除元素、编辑元素时的冲突等
    + 新增元素。采用状态合并的方式。当收到来自其他客户端的更新状态时，遍历本地的ExcalidrawElement.id和收到的ExcalidrawElement.id，取两者的并集
    + 删除元素。取两者的并集又会带来一个问题，如果某个节点删除了某个元素，由于并集的问题，会造成这个元素删除不了，因此Excalidraw增加了一个isDeleted字段
    + 并行编辑元素。添加版本号字段，只要编辑了某个元素，则增加该元素的版本号，然后再同步给其他端，合并状态时，只保留最新版本的状态。当然这仅仅是解决了多人编辑不同的元素时的冲突
    + 多人同时编辑同一元素。Excalidraw认为这是一个比较少见的场景，毕竟大家看到别人在编辑某个元素时，出于常识也不会再去编辑这个元素。但Excalidraw还是通过技术手段解决了这个冲突，Excalidraw给每个元素都增加了一个versionNonce字段。每次只要version增加了，都将versionNonce设置成一个随机整数。在合并的时候，如果遇到version相同的两个元素，则保留值较小的versionNonce对应的状态

## 目前发现的不足
- 功能上
    - 多人协作撤销重做暂未实现
    - 撤销重做有点设计缺陷。比如添加一个元素el1，对el1操作15次，然后撤销5次，再添加一个新的元素el2，此时点击一次撤销，再点击2次重做，会发现el1已经无法重做了，不知是设计如此，还是bug？

- 代码上
    - 代码组织混乱，比如组件的组织方式
    - pc端和移动端监听事件耦合在一起。比如在同一个onPointerUp判断是pc端还是移动端的事件，理论上这两者逻辑需要解耦





## 源码笔记
- onPoinerDown
    - 调用savePointer保存第一次点击事件的信息，其中需要将视图坐标转换成Scene坐标
        - 转换需要考虑zoom缩放比例以及水平和垂直方向的位移