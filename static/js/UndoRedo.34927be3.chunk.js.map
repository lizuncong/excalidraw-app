{"version":3,"file":"static/js/UndoRedo.34927be3.chunk.js","mappings":"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","sources":["webpack://excalidraw-app/./src/pages/undo-redo/index.module.less?579f","pages/undo-redo/renderScene.js","pages/undo-redo/History/utils.js","pages/undo-redo/History/index.js","pages/undo-redo/index.jsx","util/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"undoRedo\":\"index_undoRedo__mOw1J\",\"canvas\":\"index_canvas__s497j\",\"container\":\"index_container__JGkWk\",\"markdown-body\":\"index_markdown-body__Q1c3C\",\"btnRow\":\"index_btnRow__ReEOR\"};","import { elements } from \"./index\";\n\nconst renderElements = (ctx, appState) => {\n  elements.forEach((ele) => {\n    ctx.save();\n    ctx.beginPath();\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = ele.strokeStyle;\n\n    ele.points.forEach((point, index) => {\n      if (!index) {\n        ctx.moveTo(...ele.points[0]);\n      } else {\n        ctx.lineTo(...point);\n      }\n    });\n\n    ctx.stroke();\n\n    ctx.restore();\n  });\n};\nconst renderScene = (canvas, appState) => {\n  const context = canvas.getContext(\"2d\");\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  renderElements(context, appState);\n  localStorage.setItem(\"free-draw-elements\", JSON.stringify(elements));\n};\n\nexport default renderScene;\n","export const deepCopyElement = (val, depth = 0) => {\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    const tmp =\n      typeof val.constructor === \"function\"\n        ? Object.create(Object.getPrototypeOf(val))\n        : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy non-serializable objects like these caches. They'll be\n        // populated when the element is rendered.\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  return val;\n};\n\n\n\n","import { deepCopyElement } from \"./utils\";\n\nconst clearAppStatePropertiesForHistory = (appState) => {\n  return {\n    selectedElementIds: appState.selectedElementIds,\n    selectedGroupIds: appState.selectedGroupIds,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    editingLinearElement: appState.editingLinearElement,\n    editingGroupId: appState.editingGroupId,\n    name: appState.name,\n  };\n};\n\nclass History {\n  constructor() {\n    this.elementCache = new Map();\n    this.stateHistory = [];\n    this.redoStack = [];\n    this.lastEntry = null;\n  }\n  // appState只存储部分属性，并不是全部\n  hydrateHistoryEntry({ appState, elements }) {\n    return {\n      appState: JSON.parse(appState),\n      elements: elements.map((dehydratedExcalidrawElement) => {\n        const element = this.elementCache\n          .get(dehydratedExcalidrawElement.id)\n          ?.get(dehydratedExcalidrawElement.versionNonce);\n        if (!element) {\n          throw new Error(\n            `Element not found: ${dehydratedExcalidrawElement.id}:${dehydratedExcalidrawElement.versionNonce}`\n          );\n        }\n        return element;\n      }),\n    };\n  }\n\n  dehydrateHistoryEntry({ appState, elements }) {\n    return {\n      appState: JSON.stringify(appState),\n      elements: elements.map((element) => {\n        if (!this.elementCache.has(element.id)) {\n          this.elementCache.set(element.id, new Map());\n        }\n        const versions = this.elementCache.get(element.id);\n        if (!versions.has(element.versionNonce)) {\n          versions.set(element.versionNonce, deepCopyElement(element));\n        }\n        return {\n          id: element.id,\n          versionNonce: element.versionNonce,\n        };\n      }),\n    };\n  }\n\n  // 将当前state和elements生成一个快照，格式：{ appState: string, elements: [{id, versionNonce}] }\n  generateEntry = (appState, elements) =>\n    this.dehydrateHistoryEntry({\n      appState: clearAppStatePropertiesForHistory(appState),\n      elements,\n    });\n\n  pushEntry(appState, elements) {\n    const newEntryDehydrated = this.generateEntry(appState, elements);\n    const newEntry = this.hydrateHistoryEntry(newEntryDehydrated);\n    console.log('push entry=====', newEntry)\n    if (newEntry) {\n      if (!this.shouldCreateEntry(newEntry)) {\n        return;\n      }\n      console.log('create new entry=====')\n      this.stateHistory.push(newEntryDehydrated);\n      this.lastEntry = newEntry;\n      // As a new entry was pushed, we invalidate the redo stack\n      this.clearRedoStack();\n    }\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce() {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n\n    const entryToRestore = this.redoStack.pop();\n\n    if (entryToRestore !== undefined) {\n      this.stateHistory.push(entryToRestore);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  undoOnce() {\n    if (this.stateHistory.length === 1) {\n      return null;\n    }\n\n    const currentEntry = this.stateHistory.pop();\n\n    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];\n\n    if (currentEntry !== undefined) {\n      this.redoStack.push(currentEntry);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  /**\n   * Updates history's `lastEntry` to latest app state. This is necessary\n   *  when doing undo/redo which itself doesn't commit to history, but updates\n   *  app state in a way that would break `shouldCreateEntry` which relies on\n   *  `lastEntry` to reflect last comittable history state.\n   * We can't update `lastEntry` from within history when calling undo/redo\n   *  because the action potentially mutates appState/elements before storing\n   *  it.\n   */\n  setCurrentState(appState, elements) {\n    this.lastEntry = this.hydrateHistoryEntry(\n      this.generateEntry(appState, elements)\n    );\n  }\n\n  record(state, elements) {\n    this.pushEntry(state, elements);\n  }\n  clear() {\n    this.stateHistory.length = 0;\n    this.redoStack.length = 0;\n    this.lastEntry = null;\n    this.elementCache.clear();\n  }\n\n  shouldCreateEntry(nextEntry) {\n    const { lastEntry } = this;\n\n    if (!lastEntry) {\n      return true;\n    }\n\n    if (nextEntry.elements.length !== lastEntry.elements.length) {\n      return true;\n    }\n\n    // loop from right to left as changes are likelier to happen on new elements\n    for (let i = nextEntry.elements.length - 1; i > -1; i--) {\n      const prev = nextEntry.elements[i];\n      const next = lastEntry.elements[i];\n      if (\n        !prev ||\n        !next ||\n        prev.id !== next.id ||\n        prev.versionNonce !== next.versionNonce\n      ) {\n        return true;\n      }\n    }\n\n    // note: this is safe because entry's appState is guaranteed no excess props\n    let key;\n    for (key in nextEntry.appState) {\n      if (key === \"editingLinearElement\") {\n        if (\n          nextEntry.appState[key]?.elementId ===\n          lastEntry.appState[key]?.elementId\n        ) {\n          continue;\n        }\n      }\n      if (key === \"selectedElementIds\" || key === \"selectedGroupIds\") {\n        continue;\n      }\n      if (nextEntry.appState[key] !== lastEntry.appState[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n\nexport default History;\n\n// 1 25","import React, { memo, useRef, useEffect } from \"react\";\nimport { viewportCoordsToSceneCoords, rgb } from \"@/util\";\nimport styles from \"./index.module.less\";\nimport renderScene from \"./renderScene\";\nimport History from \"./History\";\n\nexport const elements =\n  JSON.parse(localStorage.getItem(\"free-draw-elements\")) || [];\nconst appState = {\n  offsetLeft: 0,\n  offsetTop: 0,\n  scrollX: 0,\n  scrollY: 0,\n  draggingElement: null,\n};\nconst history = new History();\nconsole.log('history...', history)\nconst Canvas = memo(() => {\n  const canvasRef = useRef(null);\n  const canvasContainer = useRef(null);\n  useEffect(() => {\n    // canvas分辨率矫正\n    const canvas = canvasRef.current;\n    const context = canvas.getContext(\"2d\");\n    const { offsetWidth, offsetHeight, offsetLeft, offsetTop } = canvas;\n    canvas.width = offsetWidth * window.devicePixelRatio;\n    canvas.height = offsetHeight * window.devicePixelRatio;\n    context.scale(window.devicePixelRatio, window.devicePixelRatio);\n    appState.offsetLeft = offsetLeft;\n    appState.offsetTop = offsetTop;\n    renderScene(canvas, appState);\n\n    // 防止双指滑动时切换页面\n    const wrap = canvasContainer.current;\n    const handleWheel = (e) => {\n      e.preventDefault();\n    };\n    // 防止双指滑动时切换页面\n    wrap.addEventListener(\"wheel\", handleWheel, {\n      passive: false,\n    });\n    return () => {\n      wrap.removeEventListener(\"wheel\", handleWheel);\n    };\n  }, []);\n  const handleCanvasPointerDown = (event) => {\n    const origin = viewportCoordsToSceneCoords(event, appState);\n\n    const pointerDownState = {\n      origin,\n      lastCoords: { ...origin },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n      },\n    };\n    const element = {\n      x: pointerDownState.origin.x,\n      y: pointerDownState.origin.y,\n      points: [[pointerDownState.origin.x, pointerDownState.origin.y]],\n      strokeColor: \"#000000\",\n      backgroundColor: \"transparent\",\n      fillStyle: \"hachure\",\n      strokeWidth: 1,\n      strokeStyle: rgb(),\n    };\n    appState.draggingElement = element;\n    elements.push(element);\n\n    const onPointerMove =\n      onPointerMoveFromCanvasPointerDownHandler(pointerDownState);\n    const onPointerUp =\n      onPointerUpFromCanvasPointerDownHandler(pointerDownState);\n    window.addEventListener(\"pointermove\", onPointerMove);\n    window.addEventListener(\"pointerup\", onPointerUp);\n    pointerDownState.eventListeners.onMove = onPointerMove;\n    pointerDownState.eventListeners.onUp = onPointerUp;\n  };\n  const onPointerMoveFromCanvasPointerDownHandler =\n    (pointerDownState) => (event) => {\n      const pointerCoords = viewportCoordsToSceneCoords(event, appState);\n\n      appState.draggingElement.points.push([pointerCoords.x, pointerCoords.y]);\n      renderScene(canvasRef.current, appState);\n    };\n\n  const onPointerUpFromCanvasPointerDownHandler = (pointerDownState) => () => {\n    window.removeEventListener(\n      \"pointermove\",\n      pointerDownState.eventListeners.onMove\n    );\n    window.removeEventListener(\n      \"pointerup\",\n      pointerDownState.eventListeners.onUp\n    );\n  };\n  return (\n    <div className={styles.undoRedo}>\n      <div className={styles.container} ref={canvasContainer}>\n        <canvas\n          ref={canvasRef}\n          className={styles.canvas}\n          onPointerDown={handleCanvasPointerDown}\n        >\n          绘制canvas\n        </canvas>\n        <div className={styles.btnRow}>\n          <button>撤销</button>\n          <button>重做</button>\n        </div>\n      </div>\n    </div>\n  );\n});\n\nexport default Canvas;\n","import { unstable_batchedUpdates } from \"react-dom\";\n\nexport const sceneCoordsToViewportCoords = (\n  { sceneX, sceneY },\n  { offsetLeft, offsetTop, scrollX, scrollY }\n) => {\n  const x = sceneX + scrollX + offsetLeft;\n  const y = sceneY + scrollY + offsetTop;\n  return { x, y };\n};\nexport const viewportCoordsToSceneCoords = (\n  { clientX, clientY },\n  { zoom, offsetLeft, offsetTop, scrollX, scrollY }\n) => {\n  const zoomValue = zoom ? zoom.value : 1;\n  const x = (clientX - offsetLeft) / zoomValue - scrollX;\n  const y = (clientY - offsetTop) / zoomValue - scrollY;\n  return { x, y };\n};\n\n//rgb颜色随机\nexport const rgb = () => {\n  const r = Math.floor(Math.random() * 256);\n  const g = Math.floor(Math.random() * 256);\n  const b = Math.floor(Math.random() * 256);\n  return `rgb(${r},${g},${b})`;\n};\n\nexport const throttleRAF = (fn, opts) => {\n  let timerId = null;\n  let lastArgs = null;\n  let lastArgsTrailing = null;\n\n  const scheduleFunc = (args) => {\n    timerId = window.requestAnimationFrame(() => {\n      timerId = null;\n      fn(...args);\n      lastArgs = null;\n      if (lastArgsTrailing) {\n        lastArgs = lastArgsTrailing;\n        lastArgsTrailing = null;\n        scheduleFunc(lastArgs);\n      }\n    });\n  };\n\n  const ret = (...args) => {\n    if (process.env.NODE_ENV === \"test\") {\n      fn(...args);\n      return;\n    }\n    lastArgs = args;\n    if (timerId === null) {\n      scheduleFunc(lastArgs);\n    } else if (opts?.trailing) {\n      lastArgsTrailing = args;\n    }\n  };\n  ret.flush = () => {\n    if (timerId !== null) {\n      cancelAnimationFrame(timerId);\n      timerId = null;\n    }\n    if (lastArgs) {\n      fn(...(lastArgsTrailing || lastArgs));\n      lastArgs = lastArgsTrailing = null;\n    }\n  };\n  ret.cancel = () => {\n    lastArgs = lastArgsTrailing = null;\n    if (timerId !== null) {\n      cancelAnimationFrame(timerId);\n      timerId = null;\n    }\n  };\n  return ret;\n};\nexport const withBatchedUpdatesThrottled = (func) => {\n  return throttleRAF((event) => {\n    unstable_batchedUpdates(func, event);\n  });\n};\n\nexport const getBoundsFromPoints = (element) => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let points = element.points;\n  if (element.type === \"freedraw\") {\n    points = element.points.map((p) => {\n      return [p[0] - element.x, p[1] - element.y];\n    });\n  }\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const rotate = (x1, y1, x2, y2, angle) =>\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const getElementBounds = (element) => {\n  let bounds;\n\n  const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(element);\n\n  if (element.type === \"freedraw\") {\n    const [minX, minY, maxX, maxY] = getBoundsFromPoints(element);\n\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  } else {\n    const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    bounds = [minX, minY, maxX, maxY];\n  }\n\n  return bounds;\n};\nexport const getCommonBounds = (elements) => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\nexport const getElementAbsoluteCoords = (element) => {\n  if (element.type === \"freedraw\") {\n    const [minX, minY, maxX, maxY] = getBoundsFromPoints(element);\n    const x1 = minX + element.x;\n    const y1 = minY + element.y;\n    const x2 = maxX + element.x;\n    const y2 = maxY + element.y;\n    return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n    element.x + element.width / 2,\n    element.y + element.height / 2,\n  ];\n};\n\nexport const distance = (x, y) => Math.abs(x - y);\n\nexport const getSizeFromPoints = (points) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\n\nlet testIdBase = 0;\nexport const randomId = () => `id${testIdBase++}`;\nexport const randomInteger = () => Math.floor(Math.random() * 2 ** 31);\n\nexport const generateExcalidrawElements = () => {\n  const freeDrawElements =\n    JSON.parse(localStorage.getItem(\"free-draw-elements\")) || [];\n  const result = freeDrawElements.map((ele) => {\n    const points = ele.points.map((p) => {\n      return [p[0] - ele.x, p[1] - ele.y];\n    });\n    const { width, height } = getSizeFromPoints(points);\n    return {\n      id: randomId(),\n      type: \"freedraw\",\n      x: ele.x,\n      y: ele.y,\n      width: width,\n      height: height,\n      angle: 0,\n      strokeColor: ele.strokeStyle,\n      backgroundColor: \"transparent\",\n      fillStyle: \"hachure\",\n      strokeWidth: 1,\n      strokeStyle: \"solid\",\n      roughness: 1,\n      opacity: 100,\n      groupIds: [],\n      roundness: null,\n      seed: randomInteger(),\n      version: 1,\n      versionNonce: 0,\n      isDeleted: false,\n      boundElements: null,\n      updated: Date.now(),\n      link: null,\n      locked: false,\n      points: points,\n      pressures: [],\n      simulatePressure: true,\n      lastCommittedPoint: points[points.length - 1],\n    };\n  });\n  return result;\n};\n\n// for worker\n// window.__generateExcalidrawElements = generateExcalidrawElements;\n\nexport const getFontString = ({ fontSize, fontFamily }) => {\n  return `${fontSize}px ${fontFamily}, Segoe UI Emoji`;\n};\n"],"names":["canvas","appState","ctx","context","getContext","clearRect","width","height","elements","ele","save","beginPath","lineWidth","strokeStyle","points","forEach","point","index","lineTo","moveTo","stroke","restore","localStorage","setItem","JSON","stringify","deepCopyElement","val","depth","Object","prototype","toString","call","tmp","constructor","create","getPrototypeOf","key","hasOwnProperty","Array","isArray","k","length","arr","clearAppStatePropertiesForHistory","selectedElementIds","selectedGroupIds","viewBackgroundColor","editingLinearElement","editingGroupId","name","History","generateEntry","dehydrateHistoryEntry","this","elementCache","Map","stateHistory","redoStack","lastEntry","parse","map","dehydratedExcalidrawElement","element","get","id","versionNonce","Error","has","set","versions","newEntryDehydrated","newEntry","hydrateHistoryEntry","console","log","shouldCreateEntry","push","clearRedoStack","splice","entryToRestore","pop","undefined","currentEntry","state","pushEntry","clear","nextEntry","i","prev","next","elementId","getItem","offsetLeft","offsetTop","scrollX","scrollY","draggingElement","history","memo","canvasRef","useRef","canvasContainer","useEffect","current","offsetWidth","offsetHeight","window","devicePixelRatio","scale","renderScene","wrap","handleWheel","e","preventDefault","addEventListener","passive","removeEventListener","onPointerMoveFromCanvasPointerDownHandler","pointerDownState","event","pointerCoords","viewportCoordsToSceneCoords","x","y","onPointerUpFromCanvasPointerDownHandler","eventListeners","onMove","onUp","className","styles","ref","onPointerDown","origin","lastCoords","strokeColor","backgroundColor","fillStyle","strokeWidth","rgb","onPointerMove","onPointerUp","clientX","clientY","zoom","zoomValue","value","r","Math","floor","random","g","b","withBatchedUpdatesThrottled","func","fn","opts","timerId","lastArgs","lastArgsTrailing","scheduleFunc","args","requestAnimationFrame","ret","trailing","flush","cancelAnimationFrame","cancel","throttleRAF","unstable_batchedUpdates","getBoundsFromPoints","minX","Infinity","minY","maxX","maxY","type","p","min","max","rotate","x1","y1","x2","y2","angle","cos","sin","getElementBounds","getElementAbsoluteCoords","cx","cy","x11","y11","x12","y12","x22","y22","x21","y21","getCommonBounds","distance","abs","testIdBase","randomId","getFontString","fontSize","fontFamily"],"sourceRoot":""}