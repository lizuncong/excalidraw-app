{"version":3,"file":"static/js/DynamicLayer.d8498c13.chunk.js","mappings":"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","sources":["components/markdown/index.jsx","pages/free-draw/dynamic-layer/util.js","pages/free-draw/dynamic-layer/renderScene.js","pages/free-draw/dynamic-layer/index.jsx","util/index.js"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport rehypeRaw from \"rehype-raw\";\n// import { tomorrow } from \"react-syntax-highlighter/dist/esm/styles/prism\";\nimport \"github-markdown-css\";\n\nimport './index.less'\n\n\nfunction Shapes({ src }) {\n  const [mdText, setMdText] = useState(\"\");\n  useEffect(() => {\n    fetch(src)\n      .then((response) => response.text())\n      .then((text) => {\n        setMdText(text);\n      });\n  }, [src]);\n  return (\n    <div className=\"markdown-body\">\n      <ReactMarkdown\n        children={mdText}\n        rehypePlugins={[rehypeRaw]}\n        remarkPlugins={[remarkGfm]}\n        components={{\n          code({ node, inline, className, children, ...props }) {\n            const match = /language-(\\w+)/.exec(className || \"\");\n            return !inline && match ? (\n              <SyntaxHighlighter\n                children={String(children).replace(/\\n$/, \"\")}\n                // style={{ background: 'red'}}\n                language={match[1]}\n                className=\"my-code\"\n                PreTag=\"div\"\n                {...props}\n              />\n            ) : (\n              <code className={className} {...props}>\n                {children}\n              </code>\n            );\n          },\n        }}\n      />\n    </div>\n  );\n}\n\nexport default Shapes;\n","import { unstable_batchedUpdates } from \"react-dom\";\nexport const throttleRAF = (fn, opts) => {\n  let timerId = null;\n  let lastArgs = null;\n  let lastArgsTrailing = null;\n\n  const scheduleFunc = (args) => {\n    timerId = window.requestAnimationFrame(() => {\n      timerId = null;\n      fn(...args);\n      lastArgs = null;\n      if (lastArgsTrailing) {\n        lastArgs = lastArgsTrailing;\n        lastArgsTrailing = null;\n        scheduleFunc(lastArgs);\n      }\n    });\n  };\n\n  const ret = (...args) => {\n    if (process.env.NODE_ENV === \"test\") {\n      fn(...args);\n      return;\n    }\n    lastArgs = args;\n    if (timerId === null) {\n      scheduleFunc(lastArgs);\n    } else if (opts?.trailing) {\n      lastArgsTrailing = args;\n    }\n  };\n  ret.flush = () => {\n    if (timerId !== null) {\n      cancelAnimationFrame(timerId);\n      timerId = null;\n    }\n    if (lastArgs) {\n      fn(...(lastArgsTrailing || lastArgs));\n      lastArgs = lastArgsTrailing = null;\n    }\n  };\n  ret.cancel = () => {\n    lastArgs = lastArgsTrailing = null;\n    if (timerId !== null) {\n      cancelAnimationFrame(timerId);\n      timerId = null;\n    }\n  };\n  return ret;\n};\nexport const withBatchedUpdatesThrottled = (func) => {\n  return throttleRAF((event) => {\n    unstable_batchedUpdates(func, event);\n  });\n};\n\nexport const getBoundsFromPoints = (points) => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getElementAbsoluteCoords = (element) => {\n  const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);\n  const x1 = minX + element.x;\n  const y1 = minY + element.y;\n  const x2 = maxX + element.x;\n  const y2 = maxY + element.y;\n  return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];\n};\n\nexport const distance = (x, y) => Math.abs(x - y);\n\nexport const getSizeFromPoints = (points) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\n\nlet testIdBase = 0;\nexport const randomId = () => `id${testIdBase++}`;\nexport const randomInteger = () => Math.floor(Math.random() * 2 ** 31);\n\nexport const generateExcalidrawElements = () => {\n  const freeDrawElements =\n    JSON.parse(localStorage.getItem(\"free-draw-elements\")) || [];\n  const result = freeDrawElements.map((ele) => {\n    const points = ele.points.map((p) => {\n      return [p[0] - ele.x, p[1] - ele.y];\n    });\n    const { width, height } = getSizeFromPoints(points);\n    return {\n      id: randomId(),\n      type: \"freedraw\",\n      x: ele.x,\n      y: ele.y,\n      width: width,\n      height: height,\n      angle: 0,\n      strokeColor: ele.strokeStyle,\n      backgroundColor: \"transparent\",\n      fillStyle: \"hachure\",\n      strokeWidth: 1,\n      strokeStyle: \"solid\",\n      roughness: 1,\n      opacity: 100,\n      groupIds: [],\n      roundness: null,\n      seed: randomInteger(),\n      version: 1,\n      versionNonce: 0,\n      isDeleted: false,\n      boundElements: null,\n      updated: Date.now(),\n      link: null,\n      locked: false,\n      points: points,\n      pressures: [],\n      simulatePressure: true,\n      lastCommittedPoint: points[points.length - 1],\n    };\n  });\n  return result;\n};\n\nwindow.__generateExcalidrawElements = generateExcalidrawElements;\n\nexport const setCanvasSize = (canvas, offsetWidth, offsetHeight) => {\n  const context = canvas.getContext(\"2d\");\n\n  canvas.width = offsetWidth * window.devicePixelRatio;\n  canvas.height = offsetHeight * window.devicePixelRatio;\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n};\n","import { elements } from \"./index\";\nimport { getElementAbsoluteCoords, distance, setCanvasSize } from \"./util\";\n// let previewCanvas = null;\nconst elementWithCanvasCache = new WeakMap();\n\nexport const deleteElementCache = (element) => {\n  elementWithCanvasCache.delete(element);\n};\nconst generateCanvas = (ele) => {\n  const prevElementWithCanvas = elementWithCanvasCache.get(ele);\n\n  if (prevElementWithCanvas) {\n    return prevElementWithCanvas;\n  }\n  // 离屏canvas绘制\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n\n  // const offscreenContainer = document.getElementById(\"offscreen\");\n\n  // if (previewCanvas) {\n  //   offscreenContainer.removeChild(previewCanvas);\n  // }\n  // previewCanvas = canvas;\n  // offscreenContainer.appendChild(previewCanvas);\n\n  let [x1, y1, x2, y2] = getElementAbsoluteCoords({\n    ...ele,\n    points: ele.points.map((p) => {\n      return [p[0] - ele.x, p[1] - ele.y];\n    }),\n  });\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n  const padding = 20;\n  canvas.width = distance(x1, x2) * window.devicePixelRatio + padding * 2;\n  canvas.height = distance(y1, y2) * window.devicePixelRatio + padding * 2;\n  canvasOffsetX =\n    ele.x > x1 ? distance(ele.x, x1) * window.devicePixelRatio : 0;\n\n  canvasOffsetY =\n    ele.y > y1 ? distance(ele.y, y1) * window.devicePixelRatio : 0;\n\n  context.translate(canvasOffsetX, canvasOffsetY);\n  context.save();\n  context.translate(padding, padding);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n\n  context.lineWidth = 3;\n  context.strokeStyle = ele.strokeStyle;\n  ele.points.forEach((point, index) => {\n    let [x, y] = point;\n    x = x - ele.x;\n    y = y - ele.y;\n    if (!index) {\n      context.moveTo(x, y);\n    } else {\n      context.lineTo(x, y);\n    }\n  });\n\n  context.stroke();\n\n  context.restore();\n\n  elementWithCanvasCache.set(ele, canvas);\n  return canvas;\n};\nconst renderElements = (elements, ctx, appState) => {\n  elements.forEach((ele) => {\n    // 离屏canvas绘制\n    const canvas = generateCanvas(ele);\n    let [x1, y1, x2, y2] = getElementAbsoluteCoords({\n      ...ele,\n      points: ele.points.map((p) => {\n        return [p[0] - ele.x, p[1] - ele.y];\n      }),\n    });\n\n    const padding = 20;\n\n    // 真正绘制\n    // x1 = Math.floor(x1);\n    // x2 = Math.ceil(x2);\n    // y1 = Math.floor(y1);\n    // y2 = Math.ceil(y2);\n    const cx = ((x1 + x2) / 2 + appState.scrollX) * window.devicePixelRatio;\n    const cy = ((y1 + y2) / 2 + appState.scrollY) * window.devicePixelRatio;\n\n    ctx.save();\n    ctx.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n    ctx.translate(cx, cy);\n\n    ctx.drawImage(\n      canvas,\n      (-(x2 - x1) / 2) * window.devicePixelRatio - padding,\n      (-(y2 - y1) / 2) * window.devicePixelRatio - padding,\n      canvas.width,\n      canvas.height\n    );\n\n    ctx.restore();\n  });\n};\nlet dynamicCanvas = [];\nconst maxSize = 200; // 分割点，一个canvas负责绘制500个元素\nfunction splitElements(arr, len) {\n  const group = [];\n  for (var i = 0; i < arr.length; i += len) {\n    group.push(arr.slice(i, i + len));\n  }\n  return group;\n}\nconst renderScene = (canvasContainer, canvas, appState) => {\n  const { offsetWidth, offsetHeight } = canvas;\n\n  // 先清空上一次的canvas\n  dynamicCanvas.forEach((dynamicCanva) => {\n    canvasContainer.removeChild(dynamicCanva);\n  });\n  dynamicCanvas = [];\n  const newGroup = splitElements(elements, maxSize);\n  if (!newGroup.length) {\n    const context = canvas.getContext(\"2d\");\n    context.clearRect(0, 0, canvas.width, canvas.height);\n  }\n  newGroup.forEach((subElements, idx) => {\n    if (idx < newGroup.length - 1) {\n      const newCanvas = document.createElement(\"canvas\");\n      canvasContainer.insertBefore(newCanvas, canvas);\n      newCanvas.classList.add(`canvas`);\n      newCanvas.innerText = `动态canvas ${idx}`;\n      setCanvasSize(newCanvas, offsetWidth, offsetHeight);\n      dynamicCanvas.push(newCanvas);\n      // 绘制\n      const context = newCanvas.getContext(\"2d\");\n      Promise.resolve().then(() => {\n        renderElements(subElements, context, appState);\n      });\n    } else {\n      const context = canvas.getContext(\"2d\");\n      context.clearRect(0, 0, canvas.width, canvas.height);\n      renderElements(subElements, context, appState);\n    }\n  });\n\n  localStorage.setItem(\"free-draw-elements\", JSON.stringify(elements));\n};\n\n// const renderScene2 = (canvas, appState) => {\n//   const context = canvas.getContext(\"2d\");\n//   context.clearRect(0, 0, canvas.width, canvas.height);\n//   renderElements(context, appState);\n//   localStorage.setItem(\"free-draw-elements\", JSON.stringify(elements));\n// };\n\nconst renderDraggingElement = (ctx, appState) => {\n  const element = appState.draggingElement;\n  ctx.save();\n  ctx.beginPath();\n  ctx.lineWidth = 3;\n  ctx.strokeStyle = element.strokeStyle;\n\n  element.points.forEach((point, index) => {\n    if (!index) {\n      ctx.moveTo(...element.points[0]);\n    } else {\n      ctx.lineTo(...point);\n    }\n  });\n\n  ctx.stroke();\n\n  ctx.restore();\n};\nexport const renderDraggingScene = (canvas, appState) => {\n  const context = canvas.getContext(\"2d\");\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  renderDraggingElement(context, appState);\n};\n\nexport default renderScene;\n","import React, { memo, useRef, useEffect, useState } from \"react\";\nimport { viewportCoordsToSceneCoords, rgb } from \"@/util\";\nimport MarkDown from \"@/components/markdown\";\nimport doc from \"@doc/canvas进阶/点稀释.md\";\nimport \"./index.less\";\nimport renderScene, {\n  deleteElementCache,\n  renderDraggingScene,\n} from \"./renderScene\";\nimport { withBatchedUpdatesThrottled, setCanvasSize } from \"./util\";\nexport let elements =\n  JSON.parse(localStorage.getItem(\"free-draw-elements\")) || [];\nconst appState = {\n  offsetLeft: 0,\n  offsetTop: 0,\n  scrollX: 0,\n  scrollY: 0,\n  draggingElement: null,\n};\nconst Canvas = memo(() => {\n  const canvasRef = useRef(null);\n  const canvasContainer = useRef(null);\n  const staticCanvasRef = useRef(null);\n  const [loading, setLoading] = useState(false);\n  useEffect(() => {\n    // canvas分辨率矫正\n    const canvas = canvasRef.current;\n    const { offsetWidth, offsetHeight } = canvas;\n    setCanvasSize(canvas, offsetWidth, offsetHeight);\n    setCanvasSize(staticCanvasRef.current, offsetWidth, offsetHeight);\n    // 设置appState\n    const { x, y } = canvas.getBoundingClientRect();\n    // const offsetTop = Math.ceil(y);\n    // const offsetLeft = Math.ceil(x);\n\n    appState.offsetLeft = x; //offsetLeft;\n    appState.offsetTop = y; //offsetTop;\n    // 绘制静态canvas\n    renderScene(canvasContainer.current, staticCanvasRef.current, appState);\n\n    // 防止双指滑动时切换页面\n    const wrap = canvasContainer.current;\n    const handleWheel = (e) => {\n      e.preventDefault();\n    };\n    // 防止双指滑动时切换页面\n    wrap.addEventListener(\"wheel\", handleWheel, {\n      passive: false,\n    });\n    return () => {\n      wrap.removeEventListener(\"wheel\", handleWheel);\n    };\n  }, []);\n  useEffect(() => {\n    import(\"../multiple-layered/1500\").then((res) => {\n    });\n  }, []);\n  const handleCanvasPointerDown = (event) => {\n    const origin = viewportCoordsToSceneCoords(event, appState);\n\n    const pointerDownState = {\n      origin,\n      lastCoords: { ...origin },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n      },\n    };\n    const element = {\n      x: pointerDownState.origin.x,\n      y: pointerDownState.origin.y,\n      points: [[pointerDownState.origin.x, pointerDownState.origin.y]],\n      strokeColor: \"#000000\",\n      backgroundColor: \"transparent\",\n      fillStyle: \"hachure\",\n      strokeWidth: 1,\n      strokeStyle: rgb(),\n    };\n    appState.draggingElement = element;\n    deleteElementCache(element);\n    // elements.push(element);\n\n    const onPointerMove =\n      onPointerMoveFromCanvasPointerDownHandler(pointerDownState);\n    const onPointerUp =\n      onPointerUpFromCanvasPointerDownHandler(pointerDownState);\n    window.addEventListener(\"pointermove\", onPointerMove);\n    window.addEventListener(\"pointerup\", onPointerUp);\n    pointerDownState.eventListeners.onMove = onPointerMove;\n    pointerDownState.eventListeners.onUp = onPointerUp;\n  };\n  const onPointerMoveFromCanvasPointerDownHandler = (pointerDownState) =>\n    withBatchedUpdatesThrottled((event) => {\n      const pointerCoords = viewportCoordsToSceneCoords(event, appState);\n      appState.draggingElement.points.push([pointerCoords.x, pointerCoords.y]);\n\n      renderDraggingScene(canvasRef.current, appState);\n    });\n\n  const onPointerUpFromCanvasPointerDownHandler = (pointerDownState) => () => {\n    deleteElementCache(appState.draggingElement);\n    elements.push(appState.draggingElement);\n    const canvas = canvasRef.current;\n    const context = canvas.getContext(\"2d\");\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    renderScene(canvasContainer.current, staticCanvasRef.current, appState);\n    window.removeEventListener(\n      \"pointermove\",\n      pointerDownState.eventListeners.onMove\n    );\n    window.removeEventListener(\n      \"pointerup\",\n      pointerDownState.eventListeners.onUp\n    );\n  };\n  return (\n    <div className=\"dynamic-layer\">\n      <div className=\"container wrap\" ref={canvasContainer}>\n        <canvas ref={staticCanvasRef} className=\"canvas\">\n          静态canvas\n        </canvas>\n        <canvas\n          ref={canvasRef}\n          className=\"canvas\"\n          onPointerDown={handleCanvasPointerDown}\n        >\n          动态canvas\n        </canvas>\n        <button\n          className=\"btn clear\"\n          onClick={() => {\n            localStorage.setItem(\"free-draw-elements\", JSON.stringify([]));\n            elements = [];\n            // 绘制静态canvas\n            renderScene(canvasContainer.current, staticCanvasRef.current, appState);\n          }}\n        >\n          清空localstorage\n        </button>\n        <button\n          className=\"btn\"\n          onClick={() => {\n            if (loading) return;\n            setLoading(true);\n            import(\"../multiple-layered/1500\")\n              .then((res) => {\n                const largeData = res.default;\n                localStorage.setItem(\n                  \"free-draw-elements\",\n                  JSON.stringify(largeData)\n                );\n                elements = largeData;\n                // 绘制静态canvas\n                renderScene(canvasContainer.current, staticCanvasRef.current, appState);\n              })\n              .finally(() => {\n                setLoading(false);\n              });\n          }}\n        >\n          极限测试\n        </button>\n      </div>\n      {/* <div id=\"offscreen\"></div> */}\n      <MarkDown src={doc} />\n    </div>\n  );\n});\n\nexport default Canvas;\n","import { unstable_batchedUpdates } from \"react-dom\";\n\nexport const sceneCoordsToViewportCoords = (\n  { sceneX, sceneY },\n  { offsetLeft, offsetTop, scrollX, scrollY }\n) => {\n  const x = sceneX + scrollX + offsetLeft;\n  const y = sceneY + scrollY + offsetTop;\n  return { x, y };\n};\nexport const viewportCoordsToSceneCoords = (\n  { clientX, clientY },\n  { zoom, offsetLeft, offsetTop, scrollX, scrollY }\n) => {\n  const zoomValue = zoom ? zoom.value : 1;\n  const x = (clientX - offsetLeft) / zoomValue - scrollX;\n  const y = (clientY - offsetTop) / zoomValue - scrollY;\n  return { x, y };\n};\n\n//rgb颜色随机\nexport const rgb = () => {\n  const r = Math.floor(Math.random() * 256);\n  const g = Math.floor(Math.random() * 256);\n  const b = Math.floor(Math.random() * 256);\n  return `rgb(${r},${g},${b})`;\n};\n\nexport const throttleRAF = (fn, opts) => {\n  let timerId = null;\n  let lastArgs = null;\n  let lastArgsTrailing = null;\n\n  const scheduleFunc = (args) => {\n    timerId = window.requestAnimationFrame(() => {\n      timerId = null;\n      fn(...args);\n      lastArgs = null;\n      if (lastArgsTrailing) {\n        lastArgs = lastArgsTrailing;\n        lastArgsTrailing = null;\n        scheduleFunc(lastArgs);\n      }\n    });\n  };\n\n  const ret = (...args) => {\n    if (process.env.NODE_ENV === \"test\") {\n      fn(...args);\n      return;\n    }\n    lastArgs = args;\n    if (timerId === null) {\n      scheduleFunc(lastArgs);\n    } else if (opts?.trailing) {\n      lastArgsTrailing = args;\n    }\n  };\n  ret.flush = () => {\n    if (timerId !== null) {\n      cancelAnimationFrame(timerId);\n      timerId = null;\n    }\n    if (lastArgs) {\n      fn(...(lastArgsTrailing || lastArgs));\n      lastArgs = lastArgsTrailing = null;\n    }\n  };\n  ret.cancel = () => {\n    lastArgs = lastArgsTrailing = null;\n    if (timerId !== null) {\n      cancelAnimationFrame(timerId);\n      timerId = null;\n    }\n  };\n  return ret;\n};\nexport const withBatchedUpdatesThrottled = (func) => {\n  return throttleRAF((event) => {\n    unstable_batchedUpdates(func, event);\n  });\n};\n\nexport const getBoundsFromPoints = (element) => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let points = element.points;\n  if (element.type === \"freedraw\") {\n    points = element.points.map((p) => {\n      return [p[0] - element.x, p[1] - element.y];\n    });\n  }\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const rotate = (x1, y1, x2, y2, angle) =>\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const getElementBounds = (element) => {\n  let bounds;\n\n  const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(element);\n\n  if (element.type === \"freedraw\") {\n    const [minX, minY, maxX, maxY] = getBoundsFromPoints(element);\n\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  } else {\n    const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    bounds = [minX, minY, maxX, maxY];\n  }\n\n  return bounds;\n};\nexport const getCommonBounds = (elements) => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\nexport const getElementAbsoluteCoords = (element) => {\n  if (element.type === \"freedraw\") {\n    const [minX, minY, maxX, maxY] = getBoundsFromPoints(element);\n    const x1 = minX + element.x;\n    const y1 = minY + element.y;\n    const x2 = maxX + element.x;\n    const y2 = maxY + element.y;\n    return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n    element.x + element.width / 2,\n    element.y + element.height / 2,\n  ];\n};\n\nexport const distance = (x, y) => Math.abs(x - y);\n\nexport const getSizeFromPoints = (points) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\n\nlet testIdBase = 0;\nexport const randomId = () => `id${testIdBase++}`;\nexport const randomInteger = () => Math.floor(Math.random() * 2 ** 31);\n\nexport const generateExcalidrawElements = () => {\n  const freeDrawElements =\n    JSON.parse(localStorage.getItem(\"free-draw-elements\")) || [];\n  const result = freeDrawElements.map((ele) => {\n    const points = ele.points.map((p) => {\n      return [p[0] - ele.x, p[1] - ele.y];\n    });\n    const { width, height } = getSizeFromPoints(points);\n    return {\n      id: randomId(),\n      type: \"freedraw\",\n      x: ele.x,\n      y: ele.y,\n      width: width,\n      height: height,\n      angle: 0,\n      strokeColor: ele.strokeStyle,\n      backgroundColor: \"transparent\",\n      fillStyle: \"hachure\",\n      strokeWidth: 1,\n      strokeStyle: \"solid\",\n      roughness: 1,\n      opacity: 100,\n      groupIds: [],\n      roundness: null,\n      seed: randomInteger(),\n      version: 1,\n      versionNonce: 0,\n      isDeleted: false,\n      boundElements: null,\n      updated: Date.now(),\n      link: null,\n      locked: false,\n      points: points,\n      pressures: [],\n      simulatePressure: true,\n      lastCommittedPoint: points[points.length - 1],\n    };\n  });\n  return result;\n};\n\n// for worker\n// window.__generateExcalidrawElements = generateExcalidrawElements;\n\nexport const getFontString = ({ fontSize, fontFamily }) => {\n  return `${fontSize}px ${fontFamily}, Segoe UI Emoji`;\n};\n"],"names":["src","useState","mdText","setMdText","useEffect","fetch","then","response","text","className","children","rehypePlugins","rehypeRaw","remarkPlugins","remarkGfm","components","code","node","inline","props","match","exec","String","replace","language","PreTag","withBatchedUpdatesThrottled","func","fn","opts","timerId","lastArgs","lastArgsTrailing","scheduleFunc","args","window","requestAnimationFrame","ret","trailing","flush","cancelAnimationFrame","cancel","throttleRAF","event","unstable_batchedUpdates","getElementAbsoluteCoords","element","points","minX","Infinity","minY","maxX","maxY","x","y","Math","min","max","getBoundsFromPoints","x1","y1","x2","y2","distance","abs","testIdBase","__generateExcalidrawElements","JSON","parse","localStorage","getItem","map","ele","p","xs","point","ys","width","height","getSizeFromPoints","id","type","angle","strokeColor","strokeStyle","backgroundColor","fillStyle","strokeWidth","roughness","opacity","groupIds","roundness","seed","floor","random","version","versionNonce","isDeleted","boundElements","updated","Date","now","link","locked","pressures","simulatePressure","lastCommittedPoint","length","setCanvasSize","canvas","offsetWidth","offsetHeight","context","getContext","devicePixelRatio","scale","elementWithCanvasCache","WeakMap","deleteElementCache","delete","renderElements","elements","ctx","appState","forEach","prevElementWithCanvas","get","canvasOffsetX","canvasOffsetY","document","createElement","padding","translate","save","lineWidth","index","lineTo","moveTo","stroke","restore","set","generateCanvas","cx","scrollX","cy","scrollY","drawImage","dynamicCanvas","renderDraggingScene","clearRect","draggingElement","beginPath","renderDraggingElement","canvasContainer","dynamicCanva","removeChild","newGroup","arr","len","group","i","push","slice","splitElements","subElements","idx","newCanvas","insertBefore","classList","add","innerText","Promise","resolve","setItem","stringify","offsetLeft","offsetTop","memo","canvasRef","useRef","staticCanvasRef","loading","setLoading","current","getBoundingClientRect","renderScene","wrap","handleWheel","e","preventDefault","addEventListener","passive","removeEventListener","res","onPointerMoveFromCanvasPointerDownHandler","pointerDownState","pointerCoords","viewportCoordsToSceneCoords","onPointerUpFromCanvasPointerDownHandler","eventListeners","onMove","onUp","ref","onPointerDown","origin","lastCoords","rgb","onPointerMove","onPointerUp","onClick","largeData","default","finally","doc","clientX","clientY","zoom","zoomValue","value","r","g","b","rotate","cos","sin","getElementBounds","x11","y11","x12","y12","x22","y22","x21","y21","getCommonBounds","randomId","getFontString","fontSize","fontFamily"],"sourceRoot":""}