{"version":3,"file":"static/js/Gesture.581987e6.chunk.js","mappings":"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","sources":["pages/gesture/renderScene.js","util/gesture.js","pages/gesture/useGesture.js","pages/gesture/index.jsx","pages/gesture/zoom.js","util/zoom.js"],"sourcesContent":["import { elements } from \"./index\";\nconst drawAxis = (ctx, { zoom, scrollX, scrollY }) => {\n  ctx.save();\n  const rectH = 100 * zoom.value; // 纵轴刻度间距\n  const rectW = 100 * zoom.value; // 横轴刻度间距\n  const tickLength = 8 * zoom.value; // 刻度线长度\n  const canvas = ctx.canvas;\n  const offsetX = scrollX * zoom.value;\n  const offsetY = scrollY * zoom.value;\n  ctx.translate(offsetX, offsetY);\n  ctx.strokeStyle = \"red\";\n  ctx.fillStyle = \"red\";\n  // 绘制横轴和纵轴\n  ctx.save();\n  ctx.beginPath();\n  ctx.setLineDash([10, 10]);\n  ctx.moveTo(0, -offsetY);\n  ctx.lineTo(0, canvas.height - offsetY);\n  ctx.moveTo(-offsetX, 0);\n  ctx.lineTo(canvas.width - offsetX, 0);\n  ctx.stroke();\n  ctx.restore();\n  // 绘制横轴和纵轴刻度\n  ctx.beginPath();\n  ctx.lineWidth = 2;\n  ctx.textBaseline = \"middle\";\n  for (let i = 0; i < offsetY / rectH; i++) {\n    // 绘制纵轴负数刻度\n    ctx.moveTo(0, -i * rectH);\n    ctx.lineTo(tickLength, -i * rectH);\n    ctx.font = `${20 * zoom.value}px Arial`;\n    ctx.fillText(-i, -25, -i * rectH);\n  }\n  for (let i = 0; i < (canvas.height - offsetY) / rectH; i++) {\n    // 绘制纵轴正数刻度\n    ctx.moveTo(0, i * rectH);\n    ctx.lineTo(tickLength, i * rectH);\n    ctx.font = `${20 * zoom.value}px Arial`;\n    ctx.fillText(i, -25, i * rectH);\n  }\n  for (let i = 1; i < offsetX / rectW; i++) {\n    // 绘制横轴负数刻度\n    ctx.moveTo(-i * rectW, 0);\n    ctx.lineTo(-i * rectW, tickLength);\n    ctx.font = `${20 * zoom.value}px Arial`;\n    ctx.fillText(-i, -i * rectW - 10, -15);\n  }\n  for (let i = 1; i < (canvas.width - offsetX) / rectW; i++) {\n    // 绘制横轴正数刻度\n    ctx.moveTo(i * rectW, 0);\n    ctx.lineTo(i * rectW, tickLength);\n    ctx.font = `${20 * zoom.value}px Arial`;\n    ctx.fillText(i, i * rectW - 5, -15);\n  }\n  ctx.stroke();\n\n  ctx.restore();\n};\nconst renderElements = (ctx, appState) => {\n  elements.forEach((ele) => {\n    ctx.save();\n    // console.log(\"appStsate...\", appState.scrollX);\n    // ctx.translate(\n    //   (ele.x + appState.scrollX) * appState.zoom.value,\n    //   (ele.y + appState.scrollY) * appState.zoom.value\n    // );\n    // ctx.translate(ele.x + appState.scrollX, ele.y + appState.scrollY);\n    ctx.scale(appState.zoom.value, appState.zoom.value);\n    ctx.translate(ele.x + appState.scrollX, ele.y + appState.scrollY);\n    ctx.strokeStyle = ele.strokeStyle;\n    ctx.strokeColor = ele.strokeColor;\n    ctx.strokeRect(0, 0, ele.width, ele.height);\n    ctx.restore();\n  });\n};\nconst renderScene = (canvas, appState) => {\n  const context = canvas.getContext(\"2d\");\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  drawAxis(context, appState);\n  renderElements(context, appState);\n};\n\nexport default renderScene;\n","export const getCenter = (pointers) => {\n  const allCoords = Array.from(pointers.values());\n  return {\n    x: sum(allCoords, (coords) => coords.x) / allCoords.length,\n    y: sum(allCoords, (coords) => coords.y) / allCoords.length,\n  };\n};\n\nexport const getDistance = ([a, b]) => Math.hypot(a.x - b.x, a.y - b.y);\n\nconst sum = (array, mapper) =>\n  array.reduce((acc, item) => acc + mapper(item), 0);\n","import { useEffect } from \"react\";\nimport { getCenter, getDistance } from \"@/util/gesture\";\nimport { getNormalizedZoom, getStateForZoom } from \"@/util/zoom\";\n\nconst gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null,\n};\n\nexport const useGesture = (canvasRef, appState) => {\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const onTouchEnd = (event) => {\n      if (!event.touches.length) {\n        gesture.pointers.clear();\n      }\n    };\n    canvas.addEventListener(\"touchend\", onTouchEnd);\n    return () => {\n      canvas.removeEventListener(\"touchend\", onTouchEnd);\n    };\n  }, [canvasRef]);\n  const removePointer = (event) => {\n    gesture.pointers.delete(event.pointerId);\n  };\n  const updateGestureOnPointerDown = (event) => {\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY,\n    });\n\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = appState.zoom.value;\n      gesture.initialDistance = getDistance(\n        Array.from(gesture.pointers.values())\n      );\n    }\n  };\n  const handleCanvasPointerMove = (event, callback) => {\n    if (gesture.pointers.has(event.pointerId)) {\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY,\n      });\n    }\n    const initialScale = gesture.initialScale;\n\n    if (\n      gesture.pointers.size === 2 &&\n      gesture.lastCenter &&\n      initialScale &&\n      gesture.initialDistance\n    ) {\n      const center = getCenter(gesture.pointers);\n      const deltaX = center.x - gesture.lastCenter.x;\n      const deltaY = center.y - gesture.lastCenter.y;\n      gesture.lastCenter = center;\n\n      const distance = getDistance(Array.from(gesture.pointers.values()));\n      const scaleFactor = distance / gesture.initialDistance;\n\n      const nextZoom = scaleFactor\n        ? getNormalizedZoom(initialScale * scaleFactor)\n        : appState.zoom.value;\n      const zoomState = getStateForZoom(\n        {\n          viewportX: center.x,\n          viewportY: center.y,\n          nextZoom,\n        },\n        appState\n      );\n      Object.assign(appState, {\n        zoom: zoomState.zoom,\n        scrollX: zoomState.scrollX + deltaX / nextZoom,\n        scrollY: zoomState.scrollY + deltaY / nextZoom,\n      });\n      callback();\n    } else {\n      gesture.lastCenter =\n        gesture.initialDistance =\n        gesture.initialScale =\n          null;\n    }\n  };\n  return {\n    gesture,\n    removePointer,\n    updateGestureOnPointerDown,\n    handleCanvasPointerMove,\n  };\n};\n","import React, { memo, useRef, useEffect } from \"react\";\nimport renderScene from \"./renderScene\";\nimport { getNormalizedZoom, getStateForZoom } from \"./zoom\";\nimport { useGesture } from \"./useGesture\";\nimport \"./index.less\";\nconst appState = {\n  zoom: { value: 1 },\n  offsetLeft: 0,\n  offsetTop: 0,\n  scrollX: 0,\n  scrollY: 0,\n  draggingElement: null,\n};\nconst ZOOM_STEP = 0.1;\nexport const elements = [];\nconst viewportCoordsToSceneCoords = (\n  { clientX, clientY },\n  { zoom, offsetLeft, offsetTop, scrollX, scrollY }\n) => {\n  const x = (clientX - offsetLeft) / zoom.value - scrollX;\n  const y = (clientY - offsetTop) / zoom.value - scrollY;\n  return { x, y };\n};\nconst Canvas = memo(() => {\n  const canvasRef = useRef(null);\n  const canvasContainer = useRef(null);\n  const cursorPosition = useRef({});\n  const scaleRef = useRef();\n  useEffect(() => {\n    const render = () => {\n      const canvas = canvasRef.current;\n      const context = canvas.getContext(\"2d\");\n      const { offsetWidth, offsetHeight, offsetLeft, offsetTop } = canvas;\n      canvas.width = offsetWidth * window.devicePixelRatio;\n      canvas.height = offsetHeight * window.devicePixelRatio;\n      context.scale(window.devicePixelRatio, window.devicePixelRatio);\n\n      appState.offsetLeft = offsetLeft;\n      appState.offsetTop = offsetTop;\n      renderScene(canvas, appState);\n    };\n    render();\n    const resize = () => {\n      render();\n    };\n    window.addEventListener(\"resize\", resize);\n    return () => {\n      window.removeEventListener(\"resize\", resize);\n    };\n  }, []);\n  useEffect(() => {\n    const wrap = canvasContainer.current;\n    const handleWheel = (e) => {\n      e.preventDefault();\n    };\n    // 防止双指滑动时切换页面\n    wrap.addEventListener(\"wheel\", handleWheel, {\n      passive: false,\n    });\n    const updateCurrentCursorPosition = (event) => {\n      cursorPosition.current = {\n        cursorX: event.clientX,\n        cursorY: event.clientY,\n      };\n    };\n    document.addEventListener(\"mousemove\", updateCurrentCursorPosition);\n    return () => {\n      wrap.removeEventListener(\"wheel\", handleWheel);\n      document.removeEventListener(\"mousemove\", updateCurrentCursorPosition);\n    };\n  }, []);\n  const {\n    updateGestureOnPointerDown,\n    handleCanvasPointerMove,\n    removePointer,\n    gesture,\n  } = useGesture(canvasRef, appState);\n  const handleCanvasPointerDown = (event) => {\n    updateGestureOnPointerDown(event);\n    console.log(\"pointer down...\", gesture.pointers);\n    if (gesture.pointers.size > 1) {\n      return;\n    }\n    const origin = viewportCoordsToSceneCoords(event, appState);\n    console.log(\"origin...\", appState, origin);\n    const pointerDownState = {\n      origin,\n      lastCoords: { ...origin },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n      },\n    };\n    const element = {\n      x: pointerDownState.origin.x,\n      y: pointerDownState.origin.y,\n      width: 0,\n      height: 0,\n      strokeColor: \"#000000\",\n      backgroundColor: \"transparent\",\n      fillStyle: \"hachure\",\n      strokeWidth: 1,\n      strokeStyle: \"solid\",\n    };\n    appState.draggingElement = element;\n    elements.push(element);\n    const onPointerMove =\n      onPointerMoveFromCanvasPointerDownHandler(pointerDownState);\n    const onPointerUp =\n      onPointerUpFromCanvasPointerDownHandler(pointerDownState);\n    window.addEventListener(\"pointermove\", onPointerMove);\n    window.addEventListener(\"pointerup\", onPointerUp);\n    pointerDownState.eventListeners.onMove = onPointerMove;\n    pointerDownState.eventListeners.onUp = onPointerUp;\n  };\n  const onPointerUpFromCanvasPointerDownHandler =\n    (pointerDownState) => (event) => {\n      console.log(\"pointer up..\", event.pointerId);\n      removePointer(event);\n      window.removeEventListener(\n        \"pointermove\",\n        pointerDownState.eventListeners.onMove\n      );\n      window.removeEventListener(\n        \"pointerup\",\n        pointerDownState.eventListeners.onUp\n      );\n    };\n  const onPointerMoveFromCanvasPointerDownHandler =\n    (pointerDownState) => (event) => {\n      const pointerCoords = viewportCoordsToSceneCoords(event, appState);\n      pointerDownState.lastCoords.x = pointerCoords.x;\n      pointerDownState.lastCoords.y = pointerCoords.y;\n      // maybeDragNewGenericElement(pointerDownState, event);\n      appState.draggingElement.width =\n        pointerCoords.x - pointerDownState.origin.x;\n      appState.draggingElement.height =\n        pointerCoords.y - pointerDownState.origin.y;\n      renderScene(canvasRef.current, appState);\n    };\n  const handleCanvasWheel = (event) => {\n    const { deltaX, deltaY } = event;\n    // 关于缩放：双指放大时，deltaY是负数，缩小时，deltaY是正数\n    // 缩放，本质上就是对某个点的坐标进行变换\n    if (event.metaKey || event.ctrlKey) {\n      const sign = Math.sign(deltaY); // 只有两种情况，要么+1，要么-1\n      const MAX_STEP = ZOOM_STEP * 100; // 10\n      const absDelta = Math.abs(deltaY);\n      let delta = deltaY;\n      // delta最大为10\n      if (absDelta > MAX_STEP) {\n        delta = MAX_STEP * sign;\n      }\n      let newZoom = appState.zoom.value - delta / 100;\n      newZoom +=\n        Math.log10(Math.max(1, appState.zoom.value)) *\n        -sign *\n        Math.min(1, absDelta / 20);\n      const nextZoom = getNormalizedZoom(newZoom);\n      Object.assign(appState, {\n        ...getStateForZoom(\n          {\n            viewportX: cursorPosition.current.cursorX,\n            viewportY: cursorPosition.current.cursorY,\n            nextZoom: nextZoom,\n          },\n          appState\n        ),\n      });\n      scaleRef.current.innerText = `${(nextZoom * 100).toFixed(0)}%`;\n      renderScene(canvasRef.current, appState);\n\n      return;\n    }\n    //\n    appState.scrollX = appState.scrollX - deltaX / appState.zoom.value;\n    appState.scrollY = appState.scrollY - deltaY / appState.zoom.value;\n    renderScene(canvasRef.current, appState);\n  };\n\n  return (\n    <div className=\"gesture\">\n      <div ref={canvasContainer}>\n        <canvas\n          ref={canvasRef}\n          className=\"canvas\"\n          onPointerDown={handleCanvasPointerDown}\n          onPointerCancel={removePointer}\n          onPointerMove={(event) => {\n            console.log('pointer move====')\n            handleCanvasPointerMove(event, () => {\n              console.log(\"move.....\");\n              renderScene(canvasRef.current, appState);\n            });\n          }}\n          onWheel={handleCanvasWheel}\n        >\n          绘制canvas\n        </canvas>\n      </div>\n      <div>\n        <button\n          onClick={() => {\n            let minX = Infinity;\n            let maxX = -Infinity;\n            let minY = Infinity;\n            let maxY = -Infinity;\n\n            elements.forEach((element) => {\n              const [x1, y1, x2, y2] = [\n                element.x,\n                element.y,\n                element.x + element.width,\n                element.y + element.height,\n              ];\n              minX = Math.min(minX, x1);\n              minY = Math.min(minY, y1);\n              maxX = Math.max(maxX, x2);\n              maxY = Math.max(maxY, y2);\n            });\n\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = (maxX - minX + 20) * window.devicePixelRatio;\n            canvas.height = (maxY - minY + 20) * window.devicePixelRatio;\n            const context = canvas.getContext(\"2d\");\n            context.scale(window.devicePixelRatio, window.devicePixelRatio);\n            renderScene(canvas, {\n              ...appState,\n              scrollX: -minX + 10,\n              scrollY: -minY + 10,\n            });\n            console.log(\"导出\", elements);\n            var a = document.createElement(\"a\");\n            a.href = canvas.toDataURL();\n            a.download = \"canvas.png\";\n            a.click();\n          }}\n        >\n          导出PNG\n        </button>\n      </div>\n      <div ref={scaleRef}></div>\n      {/* <div className=\"tip\">温馨提示：可以在上面的画板中绘制矩形哦！！</div> */}\n      {/* <MarkDown src={doc} /> */}\n    </div>\n  );\n});\n\nexport default Canvas;\n","const MIN_ZOOM = 0.1;\n\nexport const getNormalizedZoom = (zoom) => {\n  return Math.max(MIN_ZOOM, Math.min(zoom, 30));\n};\n\n// export const getStateForZoom2 = (\n//   { viewportX, viewportY, nextZoom },\n//   appState\n// ) => {\n//   const appLayerX = viewportX - appState.offsetLeft;\n//   const appLayerY = viewportY - appState.offsetTop;\n\n//   const currentZoom = appState.zoom.value;\n\n//   const baseScrollX = appState.scrollX + (appLayerX - appLayerX / currentZoom);\n//   const baseScrollY = appState.scrollY + (appLayerY - appLayerY / currentZoom);\n\n//   const zoomOffsetScrollX = -(appLayerX - appLayerX / nextZoom);\n//   const zoomOffsetScrollY = -(appLayerY - appLayerY / nextZoom);\n\n//   return {\n//     scrollX: baseScrollX + zoomOffsetScrollX,\n//     scrollY: baseScrollY + zoomOffsetScrollY,\n//     zoom: {\n//       value: nextZoom,\n//     },\n//   };\n// };\n\n\nexport const getStateForZoom = (\n  { viewportX, viewportY, nextZoom },\n  appState\n) => {\n  const screenX = viewportX - appState.offsetLeft;\n  const screenY = viewportY - appState.offsetTop;\n  const currentZoom = appState.zoom.value;\n\n  return {\n    scrollX: appState.scrollX + screenX / nextZoom - screenX / currentZoom,\n    scrollY: appState.scrollY + screenY / nextZoom - screenY / currentZoom,\n    zoom: {\n      value: nextZoom,\n    }, \n  };\n};\n","const MIN_ZOOM = 0.1;\n\nexport const getNormalizedZoom = (zoom) => {\n  return Math.max(MIN_ZOOM, Math.min(zoom, 30));\n};\n\nexport const getStateForZoom = (\n  { viewportX, viewportY, nextZoom },\n  appState\n) => {\n  const screenX = viewportX - appState.offsetLeft;\n  const screenY = viewportY - appState.offsetTop;\n  const currentZoom = appState.zoom.value;\n\n  return {\n    scrollX: appState.scrollX + screenX / nextZoom - screenX / currentZoom,\n    scrollY: appState.scrollY + screenY / nextZoom - screenY / currentZoom,\n    zoom: {\n      value: nextZoom,\n    },\n  };\n};\n"],"names":["canvas","appState","context","getContext","clearRect","width","height","ctx","zoom","scrollX","scrollY","save","rectH","value","rectW","tickLength","offsetX","offsetY","translate","strokeStyle","fillStyle","beginPath","setLineDash","moveTo","lineTo","stroke","restore","lineWidth","textBaseline","i","font","fillText","drawAxis","elements","ele","scale","x","y","strokeColor","strokeRect","renderElements","getCenter","pointers","allCoords","Array","from","values","sum","coords","length","getDistance","a","b","Math","hypot","array","mapper","reduce","acc","item","gesture","Map","lastCenter","initialDistance","initialScale","useGesture","canvasRef","useEffect","current","onTouchEnd","event","touches","clear","addEventListener","removeEventListener","removePointer","delete","pointerId","updateGestureOnPointerDown","set","clientX","clientY","size","handleCanvasPointerMove","callback","has","center","deltaX","deltaY","scaleFactor","nextZoom","getNormalizedZoom","zoomState","getStateForZoom","viewportX","viewportY","Object","assign","offsetLeft","offsetTop","draggingElement","viewportCoordsToSceneCoords","Canvas","memo","useRef","canvasContainer","cursorPosition","scaleRef","render","offsetWidth","offsetHeight","window","devicePixelRatio","renderScene","resize","wrap","handleWheel","e","preventDefault","passive","updateCurrentCursorPosition","cursorX","cursorY","document","onPointerUpFromCanvasPointerDownHandler","pointerDownState","console","log","eventListeners","onMove","onUp","onPointerMoveFromCanvasPointerDownHandler","pointerCoords","lastCoords","origin","className","ref","onPointerDown","element","backgroundColor","strokeWidth","push","onPointerMove","onPointerUp","onPointerCancel","onWheel","metaKey","ctrlKey","sign","absDelta","abs","delta","ZOOM_STEP","newZoom","max","min","log10","screenX","screenY","currentZoom","innerText","toFixed","onClick","minX","Infinity","maxX","minY","maxY","forEach","x1","y1","x2","y2","createElement","href","toDataURL","download","click"],"sourceRoot":""}