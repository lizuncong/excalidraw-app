{"version":3,"file":"static/js/CreateText.c08eaa4b.chunk.js","mappings":"uSAkDA,MAvCA,SAAgB,GAAU,IAARA,EAAG,EAAHA,IAChB,GAA4BC,EAAAA,EAAAA,UAAS,IAAG,eAAjCC,EAAM,KAAEC,EAAS,KAQxB,OAPAC,EAAAA,EAAAA,YAAU,WACRC,MAAML,GACHM,MAAK,SAACC,GAAQ,OAAKA,EAASC,MAAM,IAClCF,MAAK,SAACE,GACLL,EAAUK,EACZ,GACJ,GAAG,CAACR,KAEF,gBAAKS,UAAU,gBAAe,UAC5B,SAAC,IAAa,CACZC,SAAUR,EACVS,cAAe,CAACC,EAAAA,GAChBC,cAAe,CAACC,EAAAA,GAChBC,WAAY,CACVC,KAAI,YAAO,EAAJC,KAAgD,IAA1CC,EAAM,EAANA,OAAQT,EAAS,EAATA,UAAWC,EAAQ,EAARA,SAAaS,GAAK,YAC1CC,EAAQ,iBAAiBC,KAAKZ,GAAa,IACjD,OAAQS,GAAUE,GAChB,SAAC,KAAiB,QAChBV,SAAUY,OAAOZ,GAAUa,QAAQ,MAAO,IAE1CC,SAAUJ,EAAM,GAChBX,UAAU,UACVgB,OAAO,OACHN,KAGN,iCAAMV,UAAWA,GAAeU,GAAK,aAClCT,IAGP,MAKV,C,6SCkCagB,EAAiB,SAACC,GAC7B,IAAMnB,EA9CqB,SAACA,GAC5B,OAAOA,EAAKe,QAAQ,MAAO,YAAYA,QAAQ,YAAa,KAC9D,CA4CeK,CAAcD,EAAKnB,MAmBhC,OAhBiB,kBArFK,SACtBqB,EAAK,GAgBD,IAdFC,EAAC,EAADA,EACAC,EAAC,EAADA,EACAC,EAAW,EAAXA,YACAC,EAAe,EAAfA,gBACAC,EAAS,EAATA,UACAC,EAAW,EAAXA,YACAC,EAAW,EAAXA,YACAC,EAAS,EAATA,UACAC,EAAO,EAAPA,QAAQ,EAAD,EACPC,MAAAA,OAAK,MAAG,EAAC,MACTC,OAAAA,OAAM,MAAG,EAAC,MACVC,MAAAA,OAAK,MAAG,EAAC,EAoBX,OAnBS,YAGO,CACdC,IAAIC,EAAAA,EAAAA,MACJd,KAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAQ,MAAAA,EACAC,OAAAA,EACAC,MAAAA,EACAT,YAAAA,EACAC,gBAAAA,EACAC,UAAAA,EACAC,YAAAA,EACAC,YAAAA,EACAC,UAAAA,EACAC,QAAAA,EAGJ,CAmDOM,CAAgB,OAAQjB,IAAK,IAChCnB,KAAAA,EACAqC,SAAUlB,EAAKkB,SACfC,WAAYnB,EAAKmB,WACjBC,UAAWpB,EAAKoB,UAChBC,cAAerB,EAAKqB,cAMpBC,YAAatB,EAAKsB,aAAe,KACjCC,aAAc1C,GAIlB,EAEa2C,EAAgB,SAAH,GAAkC,IAA5BN,EAAQ,EAARA,SAAUC,EAAU,EAAVA,WACxC,MAAM,GAAN,OAAUD,EAAQ,cAAMC,EAAU,mBACpC,EC3GaM,EAAa,gBCKpBC,EAAyB,IAAIC,QA8C7BC,EAAiB,SAACC,EAAKC,GAC3BC,EAAAA,SAAiB,SAACC,GAEhB,IAAMC,EA5Ca,SAACD,GACtB,IAAME,EAAwBR,EAAuBS,IAAIH,GAEzD,GAAIE,EACF,OAAOA,EAGT,IAAMD,EAASG,SAASC,cAAc,UAChCC,EAAUL,EAAOM,WAAW,MAWlCN,EAAOrB,MAAQoB,EAAIpB,MAAQ4B,OAAOC,iBAAmBC,GACrDT,EAAOpB,OAASmB,EAAInB,OAAS2B,OAAOC,iBAAmBC,GACvDJ,EAAQK,OACRL,EAAQM,UAJQ,OAKhBN,EAAQO,MAAML,OAAOC,iBAAkBD,OAAOC,kBAG9CH,EAAQQ,KAAOtB,EAAcQ,GAC7BM,EAAQ/B,UAAYyB,EAAI3B,YACxBiC,EAAQlB,UAAYY,EAAIZ,UACxB,IAAM2B,EAAQf,EAAInD,KAAKmE,MAAM,MACvBC,EAAaF,EAAMG,OAAUlB,EAAInB,OAASkC,EAAMG,OAAU,GAChEZ,EAAQa,aAAe,SACvB,IAAK,IAAIC,EAAQ,EAAGA,EAAQL,EAAMG,OAAQE,IACxCd,EAAQe,SAASN,EAAMK,GAAQ,GAAIA,EAAQ,GAAKH,GAMlD,OAHAX,EAAQgB,UAER5B,EAAuB6B,IAAIvB,EAAKC,GACzBA,CACT,CAImBuB,CAAexB,GAC9B,GAAuByB,EAAAA,EAAAA,IAAyBzB,GAAI,eAA/C0B,EAAE,KAAEC,EAAE,KAAEC,EAAE,KAAEC,EAAE,KAKbC,IAAOJ,EAAKE,GAAM,EAAI9B,EAASiC,SAAWvB,OAAOC,iBACjDuB,IAAOL,EAAKE,GAAM,EAAI/B,EAASmC,SAAWzB,OAAOC,iBAEvDZ,EAAIc,OACJd,EAAIgB,MAAM,EAAIL,OAAOC,iBAAkB,EAAID,OAAOC,kBAClDZ,EAAIe,UAAUkB,EAAIE,GAClBE,QAAQC,MACRtC,EAAIuC,UACFnC,IACG2B,EAAKF,GAAM,EAAKlB,OAAOC,iBAZZ,KAaXoB,EAAKF,GAAM,EAAKnB,OAAOC,iBAbZ,GAcdR,EAAOrB,MACPqB,EAAOpB,QAGTgB,EAAIyB,SACN,GACF,EAQA,EAPoB,SAACrB,EAAQH,GAC3B,IAAMQ,EAAUL,EAAOM,WAAW,MAClCD,EAAQ+B,UAAU,EAAG,EAAGpC,EAAOrB,MAAOqB,EAAOpB,QAC7Ce,EAAeU,EAASR,GACxBwC,aAAaC,QAAQ9C,EAAY+C,KAAKC,UAAU1C,GAClD,E,SC3EWA,EAAWyC,KAAKE,MAAMJ,aAAaK,QAAQlD,KAAgB,GAChEK,EAAW,CACf8C,WAAY,EACZC,UAAW,EACXd,QAAS,EACTE,QAAS,EACTa,YAAa,EACbC,aAAc,EACdC,gBAAiB,MAoMnB,GAlMeC,EAAAA,EAAAA,OAAK,WAClB,IAAMC,GAAYC,EAAAA,EAAAA,QAAO,MACnBC,GAAkBD,EAAAA,EAAAA,QAAO,MACzBE,GAAkBF,EAAAA,EAAAA,QAAO,MACzBG,GAAcH,EAAAA,EAAAA,QAAO,MAC3B,GAA0C7G,EAAAA,EAAAA,UAAS,IAAG,eAA/CiH,EAAa,KAAEC,EAAgB,MACtC/G,EAAAA,EAAAA,YAAU,WACR,IAAMgH,EAAgB,SAACxD,GACrB,IAAMK,EAAUL,EAAOM,WAAW,MAElCN,EAAOrB,MAAQ8E,EAAclD,OAAOC,iBACpCR,EAAOpB,OAAS8E,EAAenD,OAAOC,iBACtCH,EAAQO,MAAML,OAAOC,iBAAkBD,OAAOC,iBAChD,EAEMR,EAASiD,EAAUU,QACjBF,EAA8BzD,EAA9ByD,YAAaC,EAAiB1D,EAAjB0D,aACrBF,EAAcxD,GACdwD,EAAcJ,EAAgBO,SAE9B,MAAiB3D,EAAO4D,wBAAhB1F,EAAC,EAADA,EAAGC,EAAC,EAADA,EAIX0B,EAAS8C,WAAazE,EACtB2B,EAAS+C,UAAYzE,EACrB0B,EAASgD,YAAcY,EACvB5D,EAASiD,aAAeY,EAExBG,EAAYT,EAAgBO,QAAS9D,GAGrC,IAAMiE,EAAOX,EAAgBQ,QACvBI,EAAc,SAACC,GACnBA,EAAEC,gBACJ,EAKA,OAHAH,EAAKI,iBAAiB,QAASH,EAAa,CAC1CI,SAAS,IAEJ,WACLL,EAAKM,oBAAoB,QAASL,EACpC,CACF,GAAG,IAwCH,OACE,iBAAKlH,UAAU,cAAa,WAC1B,iBAAKA,UAAU,iBAAiBwH,IAAKlB,EAAgB,WACnD,mBAAQkB,IAAKjB,EAAiBvG,UAAU,SAAQ,iCAGhD,mBACEwH,IAAKpB,EACLpG,UAAU,cACVyH,cA/CwB,SAACC,GAC/BA,EAAMN,iBACNM,EAAMC,kBACN,OAA+BC,EAAAA,EAAAA,IAA4BF,EAAO1E,GAAzD6E,EAAM,EAATxG,EAAcyG,EAAM,EAATxG,EACXyG,EAAU9G,EAAe,CAC7BI,EAAGwG,EACHvG,EAAGwG,EACHvG,aAAayG,EAAAA,EAAAA,MACbxG,gBAAiB,cACjBC,UAAW,UACXC,YAAa,EACbC,YAAa,QACb5B,KAAM,GACNqC,SAAU,GACVC,WAAY,SACZC,UAAW,OACXC,cAAe,QAEjBS,EAASkD,gBAAkB6B,EAC3B,IAAME,EAAWzB,EAAYM,QAC7BmB,EAASC,QACT,IAAMC,EAAW,CACfnE,KAAMtB,EAAcqF,GACpBK,KAAK,GAAD,OAAKP,EAAM,MACfQ,IAAI,GAAD,OAAKP,EAAM,MACdjG,QAAS,EACTyG,MAAOP,EAAQxG,YACfa,SAAU2F,EAAQ3F,UAEpBmG,OAAOC,OAAOP,EAASQ,MAAON,GAC9B,IAAMO,EAAepF,SAASqF,eAAe,YAC7CJ,OAAOC,OAAOE,EAAaD,MAAON,GAElC,IAAMS,EAAW5F,EAASgD,YAAc6B,EACxCI,EAASQ,MAAMG,SAAQ,UAAMA,EAAQ,MACrCX,EAASQ,MAAM3G,MAAK,UAAMiG,EAAQ3F,SAAQ,MAC1C6F,EAASQ,MAAM1G,OAAM,UAAyB,IAAnBgG,EAAQ3F,SAAc,KACnD,EAU+C,iCAIzC,qBACEyG,SAAU,SAAC1B,GACT,IAAIpH,EAAOoH,EAAE2B,OAAOC,MAEdd,EAAWzB,EAAYM,QACvB8B,EAAWI,WAAWf,EAASQ,MAAMG,UAErCF,EAAepF,SAASqF,eAAe,YAC7CD,EAAaO,UAAYlJ,EACzB,IAAMmJ,EAAgBR,EAAa3B,wBAAwBjF,MAC3D,GAAIoH,EAAgBN,EAGlB,GAAIM,EAAgBN,EAAW,GAC7BxD,QAAQC,IAAI,kCACZtF,EAAO2I,EAAaO,UAClBlJ,EAAKoJ,MAAM,EAAGpJ,EAAKqE,OAAS,GAC5B,KACArE,EAAKoJ,MAAMpJ,EAAKqE,OAAS,OACtB,CACLgB,QAAQC,IAAI,8CACZ,IAAIpB,EAAQlE,EAAKmE,MAAM,MACjBkF,EAAc,GACpBnF,EAAMoF,SAAQ,SAACC,GAIb,GAHAZ,EAAaO,UAAYK,EAEvBZ,EAAa3B,wBAAwBjF,OAClB8G,EACnBQ,EAAYG,KAAKD,QAGjB,IADA,IAAIE,EAAU,EACLC,EAAI,EAAGA,EAAIH,EAAKlF,OAAQqF,IAAK,CACpC,IAAMC,EAAMJ,EAAKH,MAAMK,EAASC,GAChCf,EAAaO,UAAYS,EAEvBhB,EAAa3B,wBAAwBjF,MACnB8G,GAClBQ,EAAYG,KAAKD,EAAKH,MAAMK,EAASC,EAAI,IACzCD,EAAUC,EAAI,GACLA,IAAMH,EAAKlF,OAAS,GAC7BgF,EAAYG,KAAKD,EAAKH,MAAMK,EAASC,GAEzC,CAEJ,IACArE,QAAQC,IAAI,gBAAiB+D,GAC7BrJ,EAAOqJ,EAAYO,KAAK,MACxBjB,EAAaO,UAAYlJ,CAC3B,CAGF2G,EAAiB3G,GACjB,MAA0B2I,EAAa3B,wBAA/BjF,EAAK,EAALA,MAAOC,EAAM,EAANA,OACfkG,EAASQ,MAAM3G,MAAK,UAAMA,EAAQ,GAAE,MACpCmG,EAASQ,MAAM1G,OAAM,UAAMA,EAAM,MAEjCiB,EAASkD,gBAAgBnG,KAAOA,CAClC,EACA6J,OAAQ,WACN,IAAM7B,EAAU/E,EAASkD,gBACnB+B,EAAWzB,EAAYM,QACvB4B,EAAepF,SAASqF,eAAe,YACzCZ,EAAQhI,OACVgI,EAAQjG,MAAQ4G,EAAa9B,YAC7BmB,EAAQhG,OAAS2G,EAAa7B,aD3KV,SAACkB,GACjCnF,EAAuBiH,OAAO9B,EAChC,CC0Kc+B,CAAmB9G,EAASkD,iBAC5BjD,EAASsG,KAAKvG,EAASkD,iBACvBc,EAAYT,EAAgBO,QAAS9D,GACrC+G,YAAW,WACTrB,EAAaO,UAAY,GACzBvC,EAAiB,GACnB,GAAG,MAEL6B,OAAOC,OAAOP,EAASQ,MAAO,CAC5BL,KAAK,MACLC,IAAI,MACJvG,MAAO,OACPC,OAAO,OACPF,QAAS,GAEb,EACAkH,MAAOtC,EACPzG,UAAU,WACVwH,IAAKhB,QAGT,gBAAKvE,GAAG,eACR,SAAC,IAAQ,CAAC1C,IAAKyK,KACf,gBACEvB,MAAO,CAAEwB,WAAY,QACrBhI,GAAG,WACHiI,iBAAiB,EACjBlK,UAAU,6BAIlB,G,kSCxMa4H,EAA8B,SAAH,KAGlC,IAFFuC,EAAO,EAAPA,QAASC,EAAO,EAAPA,QACTC,EAAI,EAAJA,KAAMvE,EAAU,EAAVA,WAAYC,EAAS,EAATA,UAAWd,EAAO,EAAPA,QAASE,EAAO,EAAPA,QAElCmF,EAAYD,EAAOA,EAAKtB,MAAQ,EAGtC,MAAO,CAAE1H,GAFE8I,EAAUrE,GAAcwE,EAAYrF,EAEnC3D,GADD8I,EAAUrE,GAAauE,EAAYnF,EAEhD,EAGa6C,EAAM,WACjB,IAAMuC,EAAIC,KAAKC,MAAsB,IAAhBD,KAAKE,UACpBC,EAAIH,KAAKC,MAAsB,IAAhBD,KAAKE,UACpBE,EAAIJ,KAAKC,MAAsB,IAAhBD,KAAKE,UAC1B,MAAM,OAAN,OAAcH,EAAC,YAAII,EAAC,YAAIC,EAAC,IAC3B,EAmDaC,EAA8B,SAACC,GAC1C,OAlDyB,SAACC,EAAI7J,GAC9B,IAAI8J,EAAU,KACVC,EAAW,KACXC,EAAmB,KAEjBC,EAAe,SAAfA,EAAgBC,GACpBJ,EAAUtH,OAAO2H,uBAAsB,WACrCL,EAAU,KACVD,EAAE,qBAAIK,IACNH,EAAW,KACPC,IACFD,EAAWC,EACXA,EAAmB,KACnBC,EAAaF,GAEjB,GACF,EAEMK,EAAM,WAAc,IAAD,uBAATF,EAAI,yBAAJA,EAAI,gBAKlBH,EAAWG,EACK,OAAZJ,EACFG,EAAaF,GACA,OAAJ/J,QAAI,IAAJA,GAAAA,EAAMqK,WACfL,EAAmBE,EAEvB,EAkBA,OAjBAE,EAAIE,MAAQ,WACM,OAAZR,IACFS,qBAAqBT,GACrBA,EAAU,MAERC,IACFF,EAAE,qBAAKG,GAAoBD,IAC3BA,EAAWC,EAAmB,KAElC,EACAI,EAAII,OAAS,WACXT,EAAWC,EAAmB,KACd,OAAZF,IACFS,qBAAqBT,GACrBA,EAAU,KAEd,EACOM,CACT,CAESK,EAAY,SAACjE,IAClBkE,EAAAA,EAAAA,yBAAwBd,EAAMpD,EAChC,GACF,EAEamE,EAAsB,SAAC9D,GAClC,IAAI+D,EAAOC,IACPC,EAAOD,IACPE,GAAQF,IACRG,GAAQH,IACRI,EAASpE,EAAQoE,OACA,aAAjBpE,EAAQ3G,OACV+K,EAASpE,EAAQoE,OAAOC,KAAI,SAACC,GAC3B,MAAO,CAACA,EAAE,GAAKtE,EAAQ1G,EAAGgL,EAAE,GAAKtE,EAAQzG,EAC3C,KACD,IAC0B,EAD1B,UACoB6K,GAAM,IAA3B,2BAA6B,CAAC,IAAD,qBAAjB9K,EAAC,KAAEC,EAAC,KACdwK,EAAOtB,KAAK8B,IAAIR,EAAMzK,GACtB2K,EAAOxB,KAAK8B,IAAIN,EAAM1K,GACtB2K,EAAOzB,KAAK+B,IAAIN,EAAM5K,GACtB6K,EAAO1B,KAAK+B,IAAIL,EAAM5K,EACxB,CAAC,+BAED,MAAO,CAACwK,EAAME,EAAMC,EAAMC,EAC5B,EAEaM,EAAS,SAAC5H,EAAIC,EAAIC,EAAIC,EAAI/C,GAAK,MAC1C,EAIG4C,EAAKE,GAAM0F,KAAKiC,IAAIzK,IAAU6C,EAAKE,GAAMyF,KAAKkC,IAAI1K,GAAS8C,GAC3DF,EAAKE,GAAM0F,KAAKkC,IAAI1K,IAAU6C,EAAKE,GAAMyF,KAAKiC,IAAIzK,GAAS+C,EAC7D,EAEU4H,EAAmB,SAAC5E,GAC/B,IAEA,EAAiCpD,EAAyBoD,GAAQ,eAA3DnD,EAAE,KAAEC,EAAE,KAAEC,EAAE,KAAEC,EAAE,KAAEC,EAAE,KAAEE,EAAE,KAE7B,GAAqB,aAAjB6C,EAAQ3G,KAAqB,CAC/B,MAAiCyK,EAAoB9D,GAAQ,eAAtD+D,EAAI,KAAEE,EAAI,KAAEC,EAAI,KAAEC,EAAI,KAE7B,MAAO,CACLJ,EAAO/D,EAAQ1G,EACf2K,EAAOjE,EAAQzG,EACf2K,EAAOlE,EAAQ1G,EACf6K,EAAOnE,EAAQzG,EAEnB,CACE,MAAmBkL,EAAO5H,EAAIC,EAAIG,EAAIE,EAAI6C,EAAQ/F,OAAM,eAAjD4K,EAAG,KAAEC,EAAG,KACf,EAAmBL,EAAO5H,EAAIG,EAAIC,EAAIE,EAAI6C,EAAQ/F,OAAM,eAAjD8K,EAAG,KAAEC,EAAG,KACf,EAAmBP,EAAO1H,EAAIC,EAAIC,EAAIE,EAAI6C,EAAQ/F,OAAM,eAAjDgL,EAAG,KAAEC,EAAG,KACf,EAAmBT,EAAO1H,EAAID,EAAIG,EAAIE,EAAI6C,EAAQ/F,OAAM,eAAjDkL,EAAG,KAAEC,EAAG,KAQjB,MAHW,CAJI3C,KAAK8B,IAAIM,EAAKE,EAAKE,EAAKE,GACxB1C,KAAK8B,IAAIO,EAAKE,EAAKE,EAAKE,GACxB3C,KAAK+B,IAAIK,EAAKE,EAAKE,EAAKE,GACxB1C,KAAK+B,IAAIM,EAAKE,EAAKE,EAAKE,GAKzC,EACaC,EAAkB,SAACnK,GAC9B,IAAKA,EAASmB,OACZ,MAAO,CAAC,EAAG,EAAG,EAAG,GAGnB,IAAI0H,EAAOC,IACPE,GAAQF,IACRC,EAAOD,IACPG,GAAQH,IAUZ,OARA9I,EAASoG,SAAQ,SAACtB,GAChB,MAAyB4E,EAAiB5E,GAAQ,eAA3CnD,EAAE,KAAEC,EAAE,KAAEC,EAAE,KAAEC,EAAE,KACrB+G,EAAOtB,KAAK8B,IAAIR,EAAMlH,GACtBoH,EAAOxB,KAAK8B,IAAIN,EAAMnH,GACtBoH,EAAOzB,KAAK+B,IAAIN,EAAMnH,GACtBoH,EAAO1B,KAAK+B,IAAIL,EAAMnH,EACxB,IAEO,CAAC+G,EAAME,EAAMC,EAAMC,EAC5B,EACavH,EAA2B,SAACoD,GACvC,GAAqB,aAAjBA,EAAQ3G,KAAqB,CAC/B,MAAiCyK,EAAoB9D,GAAQ,eAAtD+D,EAAI,KAAEE,EAAI,KAAEC,EAAI,KAAEC,EAAI,KACvBtH,EAAKkH,EAAO/D,EAAQ1G,EACpBwD,EAAKmH,EAAOjE,EAAQzG,EACpBwD,EAAKmH,EAAOlE,EAAQ1G,EACpB0D,EAAKmH,EAAOnE,EAAQzG,EAC1B,MAAO,CAACsD,EAAIC,EAAIC,EAAIC,GAAKH,EAAKE,GAAM,GAAID,EAAKE,GAAM,EACrD,CACA,MAAO,CACLgD,EAAQ1G,EACR0G,EAAQzG,EACRyG,EAAQ1G,EAAI0G,EAAQjG,MACpBiG,EAAQzG,EAAIyG,EAAQhG,OACpBgG,EAAQ1G,EAAI0G,EAAQjG,MAAQ,EAC5BiG,EAAQzG,EAAIyG,EAAQhG,OAAS,EAEjC,EAEasL,EAAW,SAAChM,EAAGC,GAAC,OAAKkJ,KAAK8C,IAAIjM,EAAIC,EAAG,EAW9CiM,EAAa,EACJrL,EAAW,WAAH,kBAAcqL,IAAY,EA6C/C7J,OAAO8J,6BA1CmC,WAuCxC,OArCE9H,KAAKE,MAAMJ,aAAaK,QAAQ,wBAA0B,IAC5BuG,KAAI,SAAClJ,GACnC,IAAMiJ,EAASjJ,EAAIiJ,OAAOC,KAAI,SAACC,GAC7B,MAAO,CAACA,EAAE,GAAKnJ,EAAI7B,EAAGgL,EAAE,GAAKnJ,EAAI5B,EACnC,IACA,EApB6B,SAAC6K,GAChC,IAAMsB,EAAKtB,EAAOC,KAAI,SAACsB,GAAK,OAAKA,EAAM,EAAE,IACnCC,EAAKxB,EAAOC,KAAI,SAACsB,GAAK,OAAKA,EAAM,EAAE,IACzC,MAAO,CACL5L,MAAO0I,KAAK+B,IAAG,MAAR/B,MAAI,OAAQiD,IAAMjD,KAAK8B,IAAG,MAAR9B,MAAI,OAAQiD,IACrC1L,OAAQyI,KAAK+B,IAAG,MAAR/B,MAAI,OAAQmD,IAAMnD,KAAK8B,IAAG,MAAR9B,MAAI,OAAQmD,IAE1C,CAa8BC,CAAkBzB,GAApCrK,EAAK,EAALA,MAAOC,EAAM,EAANA,OACf,MAAO,CACLE,GAAIC,IACJd,KAAM,WACNC,EAAG6B,EAAI7B,EACPC,EAAG4B,EAAI5B,EACPQ,MAAOA,EACPC,OAAQA,EACRC,MAAO,EACPT,YAAa2B,EAAIvB,YACjBH,gBAAiB,cACjBC,UAAW,UACXC,YAAa,EACbC,YAAa,QACbC,UAAW,EACXC,QAAS,IACTgM,SAAU,GACVC,UAAW,KACXC,KA3B6BvD,KAAKC,MAAMD,KAAKE,SAAQ,SAAG,EAAK,KA4B7DsD,QAAS,EACTC,aAAc,EACdC,WAAW,EACXC,cAAe,KACfC,QAASC,KAAKC,MACdC,KAAM,KACNC,QAAQ,EACRrC,OAAQA,EACRsC,UAAW,GACXC,kBAAkB,EAClBC,mBAAoBxC,EAAOA,EAAO/H,OAAS,GAE/C,GAEF,EAIO,IAAM1B,EAAgB,SAAH,GAAkC,IAA5BN,EAAQ,EAARA,SAAUC,EAAU,EAAVA,WACxC,MAAM,GAAN,OAAUD,EAAQ,cAAMC,EAAU,mBACpC,C","sources":["components/markdown/index.jsx","pages/create-text/element.js","pages/create-text/constant.js","pages/create-text/renderScene.js","pages/create-text/index.jsx","util/index.js"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport rehypeRaw from \"rehype-raw\";\n// import { tomorrow } from \"react-syntax-highlighter/dist/esm/styles/prism\";\nimport \"github-markdown-css\";\n\nimport './index.less'\n\n\nfunction Shapes({ src }) {\n  const [mdText, setMdText] = useState(\"\");\n  useEffect(() => {\n    fetch(src)\n      .then((response) => response.text())\n      .then((text) => {\n        setMdText(text);\n      });\n  }, [src]);\n  return (\n    <div className=\"markdown-body\">\n      <ReactMarkdown\n        children={mdText}\n        rehypePlugins={[rehypeRaw]}\n        remarkPlugins={[remarkGfm]}\n        components={{\n          code({ node, inline, className, children, ...props }) {\n            const match = /language-(\\w+)/.exec(className || \"\");\n            return !inline && match ? (\n              <SyntaxHighlighter\n                children={String(children).replace(/\\n$/, \"\")}\n                // style={{ background: 'red'}}\n                language={match[1]}\n                className=\"my-code\"\n                PreTag=\"div\"\n                {...props}\n              />\n            ) : (\n              <code className={className} {...props}>\n                {children}\n              </code>\n            );\n          },\n        }}\n      />\n    </div>\n  );\n}\n\nexport default Shapes;\n","import { randomId } from \"@/util\";\nconst _newElementBase = (\n  type,\n  {\n    x,\n    y,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    width = 0,\n    height = 0,\n    angle = 0,\n    ...rest\n  }\n) => {\n  const element = {\n    id: randomId(),\n    type,\n    x,\n    y,\n    width,\n    height,\n    angle,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n  };\n  return element;\n};\nexport const normalizeText = (text) => {\n  return text.replace(/\\t/g, \"        \").replace(/\\r?\\n|\\r/g, \"\\n\");\n};\n// export const measureText = (\n//   text,\n//   font,\n//   maxWidth,\n// ) => {\n//   text = text\n//     .split(\"\\n\")\n//     // replace empty lines with single space because leading/trailing empty\n//     // lines would be stripped from computation\n//     .map((x) => x || \" \")\n//     .join(\"\\n\");\n//   const container = document.createElement(\"div\");\n//   container.style.position = \"absolute\";\n//   container.style.whiteSpace = \"pre\";\n//   container.style.font = font;\n//   container.style.minHeight = \"1em\";\n//   if (maxWidth) {\n//     const lineHeight = getApproxLineHeight(font);\n//     container.style.maxWidth = `${String(maxWidth)}px`;\n//     container.style.overflow = \"hidden\";\n//     container.style.wordBreak = \"break-word\";\n//     container.style.lineHeight = `${String(lineHeight)}px`;\n//     container.style.whiteSpace = \"pre-wrap\";\n//   }\n//   document.body.appendChild(container);\n//   container.innerText = text;\n\n//   const span = document.createElement(\"span\");\n//   span.style.display = \"inline-block\";\n//   span.style.overflow = \"hidden\";\n//   span.style.width = \"1px\";\n//   span.style.height = \"1px\";\n//   container.appendChild(span);\n//   // Baseline is important for positioning text on canvas\n//   const baseline = span.offsetTop + span.offsetHeight;\n//   // Since span adds 1px extra width to the container\n//   const width = container.offsetWidth + 1;\n//   const height = container.offsetHeight;\n\n//   document.body.removeChild(container);\n//   return { width, height, baseline };\n// };\nexport const newTextElement = (opts) => {\n  const text = normalizeText(opts.text);\n    // const metrics = measureText(text, getFontString(opts));\n  //   const offsets = getTextElementPositionOffsets(opts, metrics);\n  const textElement = {\n    ..._newElementBase(\"text\", opts),\n    text,\n    fontSize: opts.fontSize,\n    fontFamily: opts.fontFamily,\n    textAlign: opts.textAlign,\n    verticalAlign: opts.verticalAlign,\n    // x: opts.x - offsets.x,\n    // y: opts.y - offsets.y,\n    // width: metrics.width,\n    // height: metrics.height,\n    // baseline: metrics.baseline,\n    containerId: opts.containerId || null,\n    originalText: text,\n  };\n\n  return textElement;\n};\n\nexport const getFontString = ({ fontSize, fontFamily }) => {\n  return `${fontSize}px ${fontFamily}, Segoe UI Emoji`;\n};\n","export const elementKey = 'text-elements'","import { elements } from \"./index\";\nimport { getElementAbsoluteCoords } from \"@/util\";\nimport { getFontString } from \"./element\";\nimport { elementKey } from \"./constant\";\n// let previewCanvas = null;\nconst elementWithCanvasCache = new WeakMap();\n\nexport const deleteElementCache = (element) => {\n  elementWithCanvasCache.delete(element);\n};\nconst generateCanvas = (ele) => {\n  const prevElementWithCanvas = elementWithCanvasCache.get(ele);\n\n  if (prevElementWithCanvas) {\n    return prevElementWithCanvas;\n  }\n  // ç¦»å±canvasç»˜åˆ¶\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n\n  // const offscreenContainer = document.getElementById(\"offscreen\");\n\n  // if (previewCanvas) {\n  //   offscreenContainer.removeChild(previewCanvas);\n  // }\n  // previewCanvas = canvas;\n  // offscreenContainer.appendChild(previewCanvas);\n\n  const padding = 20;\n  canvas.width = ele.width * window.devicePixelRatio + padding * 2;\n  canvas.height = ele.height * window.devicePixelRatio + padding * 2;\n  context.save();\n  context.translate(padding, padding);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n\n  // ç»˜åˆ¶ç¦»å±canvas\n  context.font = getFontString(ele);\n  context.fillStyle = ele.strokeColor;\n  context.textAlign = ele.textAlign;\n  const lines = ele.text.split(\"\\n\");\n  const lineHeight = lines.length ? (ele.height / lines.length) : 18;\n  context.textBaseline = \"bottom\";\n  for (let index = 0; index < lines.length; index++) {\n    context.fillText(lines[index], 0, (index + 1) * lineHeight);\n  }\n\n  context.restore();\n\n  elementWithCanvasCache.set(ele, canvas);\n  return canvas;\n};\nconst renderElements = (ctx, appState) => {\n  elements.forEach((ele) => {\n    // ç¦»å±canvasç»˜åˆ¶\n    const canvas = generateCanvas(ele);\n    let [x1, y1, x2, y2] = getElementAbsoluteCoords(ele);\n\n    const padding = 20;\n\n    // çœŸæ­£ç»˜åˆ¶\n    const cx = ((x1 + x2) / 2 + appState.scrollX) * window.devicePixelRatio;\n    const cy = ((y1 + y2) / 2 + appState.scrollY) * window.devicePixelRatio;\n\n    ctx.save();\n    ctx.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n    ctx.translate(cx, cy);\n    console.log();\n    ctx.drawImage(\n      canvas,\n      (-(x2 - x1) / 2) * window.devicePixelRatio - padding,\n      (-(y2 - y1) / 2) * window.devicePixelRatio - padding,\n      canvas.width,\n      canvas.height\n    );\n\n    ctx.restore();\n  });\n};\nconst renderScene = (canvas, appState) => {\n  const context = canvas.getContext(\"2d\");\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  renderElements(context, appState);\n  localStorage.setItem(elementKey, JSON.stringify(elements));\n};\n\nexport default renderScene;\n","import React, { memo, useRef, useState, useEffect } from \"react\";\nimport { viewportCoordsToSceneCoords, rgb } from \"@/util\";\nimport MarkDown from \"@/components/markdown\";\nimport doc from \"@doc/canvasè¿›é˜¶/ç‚¹ç¨€é‡Š.md\";\nimport \"./index.less\";\nimport renderScene, { deleteElementCache } from \"./renderScene\";\nimport { elementKey } from \"./constant\";\nimport { newTextElement, getFontString } from \"./element\";\nexport let elements = JSON.parse(localStorage.getItem(elementKey)) || [];\nconst appState = {\n  offsetLeft: 0,\n  offsetTop: 0,\n  scrollX: 0,\n  scrollY: 0,\n  canvasWidth: 0,\n  canvasHeight: 0,\n  draggingElement: null,\n};\nconst Canvas = memo(() => {\n  const canvasRef = useRef(null);\n  const canvasContainer = useRef(null);\n  const staticCanvasRef = useRef(null);\n  const textareaRef = useRef(null);\n  const [textareaValue, setTextAreaValue] = useState(\"\");\n  useEffect(() => {\n    const setCanvasSize = (canvas) => {\n      const context = canvas.getContext(\"2d\");\n\n      canvas.width = offsetWidth * window.devicePixelRatio;\n      canvas.height = offsetHeight * window.devicePixelRatio;\n      context.scale(window.devicePixelRatio, window.devicePixelRatio);\n    };\n    // canvasåˆ†è¾¨ç‡çŸ«æ­£\n    const canvas = canvasRef.current;\n    const { offsetWidth, offsetHeight } = canvas;\n    setCanvasSize(canvas);\n    setCanvasSize(staticCanvasRef.current);\n    // è®¾ç½®appState\n    const { x, y } = canvas.getBoundingClientRect();\n    // const offsetTop = Math.ceil(y);\n    // const offsetLeft = Math.ceil(x);\n\n    appState.offsetLeft = x; //offsetLeft;\n    appState.offsetTop = y; //offsetTop;\n    appState.canvasWidth = offsetWidth;\n    appState.canvasHeight = offsetHeight;\n    // ç»˜åˆ¶é™æ€canvas\n    renderScene(staticCanvasRef.current, appState);\n\n    // é˜²æ­¢åŒæŒ‡æ»‘åŠ¨æ—¶åˆ‡æ¢é¡µé¢\n    const wrap = canvasContainer.current;\n    const handleWheel = (e) => {\n      e.preventDefault();\n    };\n    // é˜²æ­¢åŒæŒ‡æ»‘åŠ¨æ—¶åˆ‡æ¢é¡µé¢\n    wrap.addEventListener(\"wheel\", handleWheel, {\n      passive: false,\n    });\n    return () => {\n      wrap.removeEventListener(\"wheel\", handleWheel);\n    };\n  }, []);\n\n  const handleCanvasDoubleClick = (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n    let { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(event, appState);\n    const element = newTextElement({\n      x: sceneX,\n      y: sceneY,\n      strokeColor: rgb(),\n      backgroundColor: \"transparent\",\n      fillStyle: \"hachure\",\n      strokeWidth: 1,\n      strokeStyle: \"solid\",\n      text: \"\",\n      fontSize: 20,\n      fontFamily: \"Virgil\", // Helvetica Cascadia\n      textAlign: \"left\",\n      verticalAlign: \"top\",\n    });\n    appState.draggingElement = element;\n    const textarea = textareaRef.current;\n    textarea.focus();\n    const styleObj = {\n      font: getFontString(element),\n      left: `${sceneX}px`,\n      top: `${sceneY}px`,\n      opacity: 1,\n      color: element.strokeColor,\n      fontSize: element.fontSize,\n    };\n    Object.assign(textarea.style, styleObj);\n    const copyTextarea = document.getElementById(\"copyText\");\n    Object.assign(copyTextarea.style, styleObj);\n    // è¾“å…¥æ¡†é™åˆ¶æœ€å¤§å®½åº¦ï¼Œé˜²æ­¢è¾“å…¥çš„æ–‡å­—è¶…å‡ºç”»å¸ƒå®½åº¦\n    const maxWidth = appState.canvasWidth - sceneX;\n    textarea.style.maxWidth = `${maxWidth}px`;\n    textarea.style.width = `${element.fontSize}px`;\n    textarea.style.height = `${element.fontSize * 1.2}px`;\n  };\n  return (\n    <div className=\"create-text\">\n      <div className=\"container wrap\" ref={canvasContainer}>\n        <canvas ref={staticCanvasRef} className=\"canvas\">\n          é™æ€canvas\n        </canvas>\n        <canvas\n          ref={canvasRef}\n          className=\"canvas draw\"\n          onDoubleClick={handleCanvasDoubleClick}\n        >\n          åŠ¨æ€canvas\n        </canvas>\n        <textarea\n          onChange={(e) => {\n            let text = e.target.value;\n            // console.log(\"tex5....\", text, text.length);\n            const textarea = textareaRef.current;\n            const maxWidth = parseFloat(textarea.style.maxWidth);\n\n            const copyTextarea = document.getElementById(\"copyText\");\n            copyTextarea.innerText = text;\n            const copyTextWidth = copyTextarea.getBoundingClientRect().width;\n            if (copyTextWidth > maxWidth) {\n              // æ­£å¸¸è¾“å…¥çš„æƒ…å†µä¸‹ï¼Œä¸¤è€…çš„å·®å€¼ä¸ä¼šå¤ªå¤§ï¼Œåªæœ‰ç²˜è´´è¿›æ¥çš„æ–‡æœ¬æ‰ä¼šå¯¼è‡´\n              // copy textå®½åº¦çªç„¶å¢å¤§\n              if (copyTextWidth - maxWidth < 30) {\n                console.log(\"æ­£å¸¸çš„è¾“å…¥\");\n                text = copyTextarea.innerText =\n                  text.slice(0, text.length - 1) +\n                  \"\\n\" +\n                  text.slice(text.length - 1);\n              } else {\n                console.log(\"ç²˜è´´è¿›æ¥çš„æ–‡æœ¬\");\n                let lines = text.split(\"\\n\");\n                const splitResult = [];\n                lines.forEach((line) => {\n                  copyTextarea.innerText = line;\n                  const copyTextWidth =\n                    copyTextarea.getBoundingClientRect().width;\n                  if (copyTextWidth <= maxWidth) {\n                    splitResult.push(line);\n                  } else {\n                    let lastIdx = 0;\n                    for (let i = 1; i < line.length; i++) {\n                      const str = line.slice(lastIdx, i);\n                      copyTextarea.innerText = str;\n                      const copyTextWidth =\n                        copyTextarea.getBoundingClientRect().width;\n                      if (copyTextWidth > maxWidth) {\n                        splitResult.push(line.slice(lastIdx, i - 1));\n                        lastIdx = i - 1;\n                      } else if (i === line.length - 1) {\n                        splitResult.push(line.slice(lastIdx, i));\n                      }\n                    }\n                  }\n                });\n                console.log(\"splitResult..\", splitResult);\n                text = splitResult.join(\"\\n\");\n                copyTextarea.innerText = text;\n              }\n            }\n\n            setTextAreaValue(text);\n            const { width, height } = copyTextarea.getBoundingClientRect();\n            textarea.style.width = `${width + 30}px`;\n            textarea.style.height = `${height}px`;\n\n            appState.draggingElement.text = text;\n          }}\n          onBlur={() => {\n            const element = appState.draggingElement;\n            const textarea = textareaRef.current;\n            const copyTextarea = document.getElementById(\"copyText\");\n            if (element.text) {\n              element.width = copyTextarea.offsetWidth;\n              element.height = copyTextarea.offsetHeight;\n              deleteElementCache(appState.draggingElement);\n              elements.push(appState.draggingElement);\n              renderScene(staticCanvasRef.current, appState);\n              setTimeout(() => {\n                copyTextarea.innerText = \"\";\n                setTextAreaValue(\"\");\n              }, 200);\n            }\n            Object.assign(textarea.style, {\n              left: `0px`,\n              top: `0px`,\n              width: \"20px\",\n              height: `30px`,\n              opacity: 0,\n            });\n          }}\n          value={textareaValue}\n          className=\"textarea\"\n          ref={textareaRef}\n        ></textarea>\n      </div>\n      <div id=\"offscreen\"></div>\n      <MarkDown src={doc} />\n      <div\n        style={{ background: \"grey\" }}\n        id=\"copyText\"\n        contentEditable={true}\n        className=\"textarea textarea_copy\"\n      ></div>\n    </div>\n  );\n});\n\nexport default Canvas;\n","import { unstable_batchedUpdates } from \"react-dom\";\n\nexport const sceneCoordsToViewportCoords = (\n  { sceneX, sceneY },\n  { offsetLeft, offsetTop, scrollX, scrollY }\n) => {\n  const x = sceneX + scrollX + offsetLeft;\n  const y = sceneY + scrollY + offsetTop;\n  return { x, y };\n};\nexport const viewportCoordsToSceneCoords = (\n  { clientX, clientY },\n  { zoom, offsetLeft, offsetTop, scrollX, scrollY }\n) => {\n  const zoomValue = zoom ? zoom.value : 1;\n  const x = (clientX - offsetLeft) / zoomValue - scrollX;\n  const y = (clientY - offsetTop) / zoomValue - scrollY;\n  return { x, y };\n};\n\n//rgbé¢œè‰²éšæœº\nexport const rgb = () => {\n  const r = Math.floor(Math.random() * 256);\n  const g = Math.floor(Math.random() * 256);\n  const b = Math.floor(Math.random() * 256);\n  return `rgb(${r},${g},${b})`;\n};\n\nexport const throttleRAF = (fn, opts) => {\n  let timerId = null;\n  let lastArgs = null;\n  let lastArgsTrailing = null;\n\n  const scheduleFunc = (args) => {\n    timerId = window.requestAnimationFrame(() => {\n      timerId = null;\n      fn(...args);\n      lastArgs = null;\n      if (lastArgsTrailing) {\n        lastArgs = lastArgsTrailing;\n        lastArgsTrailing = null;\n        scheduleFunc(lastArgs);\n      }\n    });\n  };\n\n  const ret = (...args) => {\n    if (process.env.NODE_ENV === \"test\") {\n      fn(...args);\n      return;\n    }\n    lastArgs = args;\n    if (timerId === null) {\n      scheduleFunc(lastArgs);\n    } else if (opts?.trailing) {\n      lastArgsTrailing = args;\n    }\n  };\n  ret.flush = () => {\n    if (timerId !== null) {\n      cancelAnimationFrame(timerId);\n      timerId = null;\n    }\n    if (lastArgs) {\n      fn(...(lastArgsTrailing || lastArgs));\n      lastArgs = lastArgsTrailing = null;\n    }\n  };\n  ret.cancel = () => {\n    lastArgs = lastArgsTrailing = null;\n    if (timerId !== null) {\n      cancelAnimationFrame(timerId);\n      timerId = null;\n    }\n  };\n  return ret;\n};\nexport const withBatchedUpdatesThrottled = (func) => {\n  return throttleRAF((event) => {\n    unstable_batchedUpdates(func, event);\n  });\n};\n\nexport const getBoundsFromPoints = (element) => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let points = element.points;\n  if (element.type === \"freedraw\") {\n    points = element.points.map((p) => {\n      return [p[0] - element.x, p[1] - element.y];\n    });\n  }\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const rotate = (x1, y1, x2, y2, angle) =>\n  // ğ‘â€²ğ‘¥=(ğ‘ğ‘¥âˆ’ğ‘ğ‘¥)cosğœƒâˆ’(ğ‘ğ‘¦âˆ’ğ‘ğ‘¦)sinğœƒ+ğ‘ğ‘¥\n  // ğ‘â€²ğ‘¦=(ğ‘ğ‘¥âˆ’ğ‘ğ‘¥)sinğœƒ+(ğ‘ğ‘¦âˆ’ğ‘ğ‘¦)cosğœƒ+ğ‘ğ‘¦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const getElementBounds = (element) => {\n  let bounds;\n\n  const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(element);\n\n  if (element.type === \"freedraw\") {\n    const [minX, minY, maxX, maxY] = getBoundsFromPoints(element);\n\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  } else {\n    const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    bounds = [minX, minY, maxX, maxY];\n  }\n\n  return bounds;\n};\nexport const getCommonBounds = (elements) => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\nexport const getElementAbsoluteCoords = (element) => {\n  if (element.type === \"freedraw\") {\n    const [minX, minY, maxX, maxY] = getBoundsFromPoints(element);\n    const x1 = minX + element.x;\n    const y1 = minY + element.y;\n    const x2 = maxX + element.x;\n    const y2 = maxY + element.y;\n    return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n    element.x + element.width / 2,\n    element.y + element.height / 2,\n  ];\n};\n\nexport const distance = (x, y) => Math.abs(x - y);\n\nexport const getSizeFromPoints = (points) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\n\nlet testIdBase = 0;\nexport const randomId = () => `id${testIdBase++}`;\nexport const randomInteger = () => Math.floor(Math.random() * 2 ** 31);\n\nexport const generateExcalidrawElements = () => {\n  const freeDrawElements =\n    JSON.parse(localStorage.getItem(\"free-draw-elements\")) || [];\n  const result = freeDrawElements.map((ele) => {\n    const points = ele.points.map((p) => {\n      return [p[0] - ele.x, p[1] - ele.y];\n    });\n    const { width, height } = getSizeFromPoints(points);\n    return {\n      id: randomId(),\n      type: \"freedraw\",\n      x: ele.x,\n      y: ele.y,\n      width: width,\n      height: height,\n      angle: 0,\n      strokeColor: ele.strokeStyle,\n      backgroundColor: \"transparent\",\n      fillStyle: \"hachure\",\n      strokeWidth: 1,\n      strokeStyle: \"solid\",\n      roughness: 1,\n      opacity: 100,\n      groupIds: [],\n      roundness: null,\n      seed: randomInteger(),\n      version: 1,\n      versionNonce: 0,\n      isDeleted: false,\n      boundElements: null,\n      updated: Date.now(),\n      link: null,\n      locked: false,\n      points: points,\n      pressures: [],\n      simulatePressure: true,\n      lastCommittedPoint: points[points.length - 1],\n    };\n  });\n  return result;\n};\n\nwindow.__generateExcalidrawElements = generateExcalidrawElements;\n\nexport const getFontString = ({ fontSize, fontFamily }) => {\n  return `${fontSize}px ${fontFamily}, Segoe UI Emoji`;\n};\n"],"names":["src","useState","mdText","setMdText","useEffect","fetch","then","response","text","className","children","rehypePlugins","rehypeRaw","remarkPlugins","remarkGfm","components","code","node","inline","props","match","exec","String","replace","language","PreTag","newTextElement","opts","normalizeText","type","x","y","strokeColor","backgroundColor","fillStyle","strokeWidth","strokeStyle","roughness","opacity","width","height","angle","id","randomId","_newElementBase","fontSize","fontFamily","textAlign","verticalAlign","containerId","originalText","getFontString","elementKey","elementWithCanvasCache","WeakMap","renderElements","ctx","appState","elements","ele","canvas","prevElementWithCanvas","get","document","createElement","context","getContext","window","devicePixelRatio","padding","save","translate","scale","font","lines","split","lineHeight","length","textBaseline","index","fillText","restore","set","generateCanvas","getElementAbsoluteCoords","x1","y1","x2","y2","cx","scrollX","cy","scrollY","console","log","drawImage","clearRect","localStorage","setItem","JSON","stringify","parse","getItem","offsetLeft","offsetTop","canvasWidth","canvasHeight","draggingElement","memo","canvasRef","useRef","canvasContainer","staticCanvasRef","textareaRef","textareaValue","setTextAreaValue","setCanvasSize","offsetWidth","offsetHeight","current","getBoundingClientRect","renderScene","wrap","handleWheel","e","preventDefault","addEventListener","passive","removeEventListener","ref","onDoubleClick","event","stopPropagation","viewportCoordsToSceneCoords","sceneX","sceneY","element","rgb","textarea","focus","styleObj","left","top","color","Object","assign","style","copyTextarea","getElementById","maxWidth","onChange","target","value","parseFloat","innerText","copyTextWidth","slice","splitResult","forEach","line","push","lastIdx","i","str","join","onBlur","delete","deleteElementCache","setTimeout","doc","background","contentEditable","clientX","clientY","zoom","zoomValue","r","Math","floor","random","g","b","withBatchedUpdatesThrottled","func","fn","timerId","lastArgs","lastArgsTrailing","scheduleFunc","args","requestAnimationFrame","ret","trailing","flush","cancelAnimationFrame","cancel","throttleRAF","unstable_batchedUpdates","getBoundsFromPoints","minX","Infinity","minY","maxX","maxY","points","map","p","min","max","rotate","cos","sin","getElementBounds","x11","y11","x12","y12","x22","y22","x21","y21","getCommonBounds","distance","abs","testIdBase","__generateExcalidrawElements","xs","point","ys","getSizeFromPoints","groupIds","roundness","seed","version","versionNonce","isDeleted","boundElements","updated","Date","now","link","locked","pressures","simulatePressure","lastCommittedPoint"],"sourceRoot":""}