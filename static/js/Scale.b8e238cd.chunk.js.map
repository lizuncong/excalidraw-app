{"version":3,"file":"static/js/Scale.b8e238cd.chunk.js","mappings":"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","sources":["pages/scale/renderScene.js","pages/scale/index.jsx","pages/scale/zoom.js"],"sourcesContent":["import { elements } from \"./index\";\nconst drawAxis = (ctx, { scrollX, scrollY }) => {\n  ctx.save();\n  const rectH = 100; // 纵轴刻度间距\n  const rectW = 100; // 横轴刻度间距\n  const tickLength = 8; // 刻度线长度\n  const canvas = ctx.canvas;\n  ctx.translate(scrollX, scrollY);\n  ctx.strokeStyle = \"red\";\n  ctx.fillStyle = \"red\";\n  // 绘制横轴和纵轴\n  ctx.save();\n  ctx.beginPath();\n  ctx.setLineDash([10, 10]);\n  ctx.moveTo(0, -scrollY);\n  ctx.lineTo(0, canvas.height - scrollY);\n  ctx.moveTo(-scrollX, 0);\n  ctx.lineTo(canvas.width - scrollX, 0);\n  ctx.stroke();\n  ctx.restore();\n  // 绘制横轴和纵轴刻度\n  ctx.beginPath();\n  ctx.lineWidth = 2;\n  ctx.textBaseline = \"middle\";\n  for (let i = 0; i < scrollY / rectH; i++) {\n    // 绘制纵轴负数刻度\n    ctx.moveTo(0, -i * rectH);\n    ctx.lineTo(tickLength, -i * rectH);\n    ctx.font = \"20px Arial\";\n    ctx.fillText(-i, -25, -i * rectH);\n  }\n  for (let i = 0; i < (canvas.height - scrollY) / rectH; i++) {\n    // 绘制纵轴正数刻度\n    ctx.moveTo(0, i * rectH);\n    ctx.lineTo(tickLength, i * rectH);\n    ctx.font = \"20px Arial\";\n    ctx.fillText(i, -25, i * rectH);\n  }\n  for (let i = 1; i < scrollX / rectW; i++) {\n    // 绘制横轴负数刻度\n    ctx.moveTo(-i * rectW, 0);\n    ctx.lineTo(-i * rectW, tickLength);\n    ctx.font = \"20px Arial\";\n    ctx.fillText(-i, -i * rectW - 10, -15);\n  }\n  for (let i = 1; i < (canvas.width - scrollX) / rectW; i++) {\n    // 绘制横轴正数刻度\n    ctx.moveTo(i * rectW, 0);\n    ctx.lineTo(i * rectW, tickLength);\n    ctx.font = \"20px Arial\";\n    ctx.fillText(i, i * rectW - 5, -15);\n  }\n  ctx.stroke();\n\n  ctx.restore();\n};\nconst renderElements = (ctx, appState) => {\n  elements.forEach((ele) => {\n    ctx.save();\n    ctx.translate((ele.x + appState.scrollX) * appState.zoom.value , (ele.y + appState.scrollY) * appState.zoom.value);\n    console.log('zoom..', ele.x, ele.y, appState.scrollX, appState.scrollY, appState.zoom.value)\n    ctx.scale(appState.zoom.value, appState.zoom.value)\n    ctx.strokeStyle = ele.strokeStyle;\n    ctx.strokeColor = ele.strokeColor;\n    ctx.strokeRect(0, 0, ele.width, ele.height);\n    ctx.restore();\n  });\n};\nconst renderScene = (canvas, appState) => {\n  const context = canvas.getContext(\"2d\");\n  context.clearRect(0,0,canvas.width, canvas.height)\n  drawAxis(context, appState);\n  renderElements(context, appState)\n};\n\nexport default renderScene;\n","import React, { memo, useRef, useEffect } from \"react\";\n// import MarkDown from \"@/components/markdown\";\n// import doc from \"../../../doc/canvas进阶/绘制矩形及无限画布.md\";\nimport renderScene from \"./renderScene\";\nimport { getNormalizedZoom, getStateForZoom } from \"./zoom\";\nimport \"./index.less\";\nconst appState = {\n  zoom: { value: 1 },\n  offsetLeft: 0,\n  offsetTop: 0,\n  scrollX: 0,\n  scrollY: 0,\n  draggingElement: null,\n};\nconst ZOOM_STEP = 0.1;\nexport const elements = [];\nconst viewportCoordsToSceneCoords = (\n  { clientX, clientY },\n  { zoom, offsetLeft, offsetTop, scrollX, scrollY }\n) => {\n  const x = (clientX - offsetLeft) / zoom.value - scrollX;\n  const y = (clientY - offsetTop) / zoom.value - scrollY;\n  return { x, y };\n};\nconst Canvas = memo(() => {\n  const canvasRef = useRef(null);\n  const canvasContainer = useRef(null);\n  const cursorPosition = useRef({});\n  useEffect(() => {\n    const render = () => {\n      const canvas = canvasRef.current;\n      const context = canvas.getContext(\"2d\");\n      const { offsetWidth, offsetHeight, offsetLeft, offsetTop } = canvas;\n      canvas.width = offsetWidth * window.devicePixelRatio;\n      canvas.height = offsetHeight * window.devicePixelRatio;\n      context.scale(window.devicePixelRatio, window.devicePixelRatio);\n\n      appState.offsetLeft = offsetLeft;\n      appState.offsetTop = offsetTop;\n      renderScene(canvas, appState);\n    };\n    render();\n    const resize = () => {\n      render();\n    };\n    window.addEventListener(\"resize\", resize);\n    return () => {\n      window.removeEventListener(\"resize\", resize);\n    };\n  }, []);\n  useEffect(() => {\n    const wrap = canvasContainer.current;\n    const handleWheel = (e) => {\n      e.preventDefault();\n    };\n    // 防止双指滑动时切换页面\n    wrap.addEventListener(\"wheel\", handleWheel, {\n      passive: false,\n    });\n    const updateCurrentCursorPosition = (event) => {\n      cursorPosition.current = {\n        cursorX: event.clientX,\n        cursorY: event.clientY,\n      };\n    };\n    document.addEventListener(\"mousemove\", updateCurrentCursorPosition);\n    return () => {\n      wrap.removeEventListener(\"wheel\", handleWheel);\n      document.removeEventListener(\"mousemove\", updateCurrentCursorPosition);\n    };\n  }, []);\n  const handleCanvasPointerDown = (event) => {\n    const origin = viewportCoordsToSceneCoords(event, appState);\n    console.log(\"origin...\", appState, origin);\n    const pointerDownState = {\n      origin,\n      lastCoords: { ...origin },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n      },\n    };\n    const element = {\n      x: pointerDownState.origin.x,\n      y: pointerDownState.origin.y,\n      width: 0,\n      height: 0,\n      strokeColor: \"#000000\",\n      backgroundColor: \"transparent\",\n      fillStyle: \"hachure\",\n      strokeWidth: 1,\n      strokeStyle: \"solid\",\n    };\n    appState.draggingElement = element;\n    elements.push(element);\n    const onPointerMove =\n      onPointerMoveFromCanvasPointerDownHandler(pointerDownState);\n    const onPointerUp =\n      onPointerUpFromCanvasPointerDownHandler(pointerDownState);\n    window.addEventListener(\"pointermove\", onPointerMove);\n    window.addEventListener(\"pointerup\", onPointerUp);\n    pointerDownState.eventListeners.onMove = onPointerMove;\n    pointerDownState.eventListeners.onUp = onPointerUp;\n  };\n  const onPointerUpFromCanvasPointerDownHandler =\n    (pointerDownState) => (event) => {\n      window.removeEventListener(\n        \"pointermove\",\n        pointerDownState.eventListeners.onMove\n      );\n      window.removeEventListener(\n        \"pointerup\",\n        pointerDownState.eventListeners.onUp\n      );\n    };\n  const onPointerMoveFromCanvasPointerDownHandler =\n    (pointerDownState) => (event) => {\n      const pointerCoords = viewportCoordsToSceneCoords(event, appState);\n      pointerDownState.lastCoords.x = pointerCoords.x;\n      pointerDownState.lastCoords.y = pointerCoords.y;\n      // maybeDragNewGenericElement(pointerDownState, event);\n      appState.draggingElement.width =\n        pointerCoords.x - pointerDownState.origin.x;\n      appState.draggingElement.height =\n        pointerCoords.y - pointerDownState.origin.y;\n      renderScene(canvasRef.current, appState);\n    };\n  const handleCanvasWheel = (event) => {\n    const { deltaX, deltaY } = event;\n    // 关于缩放：双指放大时，deltaY是负数，缩小时，deltaY是正数\n    // 缩放，本质上就是对某个点的坐标进行变换\n    if (event.metaKey || event.ctrlKey) {\n      const sign = Math.sign(deltaY); // 只有两种情况，要么+1，要么-1\n      const MAX_STEP = ZOOM_STEP * 100; // 10\n      const absDelta = Math.abs(deltaY);\n      let delta = deltaY;\n      // delta最大为10\n      if (absDelta > MAX_STEP) {\n        delta = MAX_STEP * sign;\n      }\n      let newZoom = appState.zoom.value - delta / 100;\n      newZoom +=\n        Math.log10(Math.max(1, appState.zoom.value)) *\n        -sign *\n        Math.min(1, absDelta / 20);\n\n      Object.assign(appState, {\n        ...getStateForZoom(\n          {\n            viewportX: cursorPosition.current.cursorX,\n            viewportY: cursorPosition.current.cursorY,\n            nextZoom: getNormalizedZoom(newZoom),\n          },\n          appState\n        ),\n      });\n      renderScene(canvasRef.current, appState);\n\n      return;\n    }\n    //\n    console.log('hello...')\n    appState.scrollX = appState.scrollX - deltaX / appState.zoom.value;\n    appState.scrollY = appState.scrollY - deltaY / appState.zoom.value;\n    renderScene(canvasRef.current, appState);\n  };\n  return (\n    <div className=\"infinite-canvas\">\n      <div ref={canvasContainer}>\n        <canvas\n          ref={canvasRef}\n          className=\"canvas\"\n          onPointerDown={handleCanvasPointerDown}\n          onWheel={handleCanvasWheel}\n        >\n          绘制canvas\n        </canvas>\n      </div>\n      <div>\n        <button\n          onClick={() => {\n            let minX = Infinity;\n            let maxX = -Infinity;\n            let minY = Infinity;\n            let maxY = -Infinity;\n\n            elements.forEach((element) => {\n              const [x1, y1, x2, y2] = [\n                element.x,\n                element.y,\n                element.x + element.width,\n                element.y + element.height,\n              ];\n              minX = Math.min(minX, x1);\n              minY = Math.min(minY, y1);\n              maxX = Math.max(maxX, x2);\n              maxY = Math.max(maxY, y2);\n            });\n\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = (maxX - minX + 20) * window.devicePixelRatio;\n            canvas.height = (maxY - minY + 20) * window.devicePixelRatio;\n            const context = canvas.getContext(\"2d\");\n            context.scale(window.devicePixelRatio, window.devicePixelRatio);\n            renderScene(canvas, {\n              ...appState,\n              scrollX: -minX + 10,\n              scrollY: -minY + 10,\n            });\n            console.log(\"导出\", elements);\n            var a = document.createElement(\"a\");\n            a.href = canvas.toDataURL();\n            a.download = \"canvas.png\";\n            a.click();\n          }}\n        >\n          导出PNG\n        </button>\n      </div>\n      {/* <div className=\"tip\">温馨提示：可以在上面的画板中绘制矩形哦！！</div> */}\n      {/* <MarkDown src={doc} /> */}\n    </div>\n  );\n});\n\nexport default Canvas;\n","const MIN_ZOOM = 0.1;\n\nexport const getNormalizedZoom = (zoom) => {\n  return Math.max(MIN_ZOOM, Math.min(zoom, 30));\n};\n\nexport const getStateForZoom = (\n  { viewportX, viewportY, nextZoom },\n  appState\n) => {\n  const appLayerX = viewportX - appState.offsetLeft;\n  const appLayerY = viewportY - appState.offsetTop;\n\n  const currentZoom = appState.zoom.value;\n\n  const baseScrollX = appState.scrollX + (appLayerX - appLayerX / currentZoom);\n  const baseScrollY = appState.scrollY + (appLayerY - appLayerY / currentZoom);\n\n  // get scroll offsets for target zoom level\n  const zoomOffsetScrollX = -(appLayerX - appLayerX / nextZoom);\n  const zoomOffsetScrollY = -(appLayerY - appLayerY / nextZoom);\n\n  return {\n    scrollX: baseScrollX + zoomOffsetScrollX,\n    scrollY: baseScrollY + zoomOffsetScrollY,\n    zoom: {\n      value: nextZoom,\n    },\n  };\n};\n\n"],"names":["canvas","appState","context","getContext","clearRect","width","height","ctx","scrollX","scrollY","save","rectH","rectW","translate","strokeStyle","fillStyle","beginPath","setLineDash","moveTo","lineTo","stroke","restore","lineWidth","textBaseline","i","font","fillText","drawAxis","elements","ele","x","zoom","value","y","console","log","scale","strokeColor","strokeRect","renderElements","offsetLeft","offsetTop","draggingElement","viewportCoordsToSceneCoords","clientX","clientY","memo","canvasRef","useRef","canvasContainer","cursorPosition","useEffect","render","current","offsetWidth","offsetHeight","window","devicePixelRatio","renderScene","resize","addEventListener","removeEventListener","wrap","handleWheel","e","preventDefault","passive","updateCurrentCursorPosition","event","cursorX","cursorY","document","onPointerUpFromCanvasPointerDownHandler","pointerDownState","eventListeners","onMove","onUp","onPointerMoveFromCanvasPointerDownHandler","pointerCoords","lastCoords","origin","className","ref","onPointerDown","element","backgroundColor","strokeWidth","push","onPointerMove","onPointerUp","onWheel","deltaX","deltaY","metaKey","ctrlKey","sign","Math","absDelta","abs","delta","ZOOM_STEP","newZoom","log10","max","min","Object","assign","viewportX","viewportY","nextZoom","appLayerX","appLayerY","currentZoom","getStateForZoom","onClick","minX","Infinity","maxX","minY","maxY","forEach","x1","y1","x2","y2","createElement","a","href","toDataURL","download","click"],"sourceRoot":""}