## 前言

本节我们通过简单的矩形绘制学习如何实现无限画布

## 准备工作

在绘制前，我们需要矫正 canvas 的分辨率，使用 appState 保存 canvas 相关的信息。新建一个 index.jsx 文件，初始化代码如下：

```jsx
const appState = {
  offsetLeft: 0,
  offsetTop: 0,
};
const Canvas = memo(() => {
  const canvasRef = useRef(null);
  const canvasContainer = useRef(null);
  useEffect(() => {
    const canvas = canvasRef.current;
    const context = canvas.getContext("2d");
    const { offsetWidth, offsetHeight, offsetLeft, offsetTop } = canvas;
    canvas.width = offsetWidth * window.devicePixelRatio;
    canvas.height = offsetHeight * window.devicePixelRatio;
    context.scale(window.devicePixelRatio, window.devicePixelRatio);

    appState.offsetLeft = offsetLeft;
    appState.offsetTop = offsetTop;
  }, []);

  return (
    <div ref={canvasContainer}>
      <canvas ref={canvasRef} className="canvas">
        绘制canvas
      </canvas>
    </div>
  );
});
```

## 绘制坐标轴

为方便观察，首先在 canvas 上绘制一个坐标轴。新建一个 renderScene.js 文件，实现 drawAxis 方法：

```js
const drawAxis = (ctx) => {
  ctx.save();
  const rectH = 100; // 纵轴刻度间距
  const rectW = 100; // 横轴刻度间距
  const tickLength = 8; // 刻度线长度
  const canvas = ctx.canvas;
  ctx.translate(0, 0);
  ctx.strokeStyle = "red";
  ctx.fillStyle = "red";
  // 绘制横轴和纵轴
  ctx.save();
  ctx.beginPath();
  ctx.setLineDash([10, 10]);
  ctx.moveTo(0, 0);
  ctx.lineTo(0, canvas.height);
  ctx.moveTo(0, 0);
  ctx.lineTo(canvas.width, 0);
  ctx.stroke();
  ctx.restore();
  // 绘制横轴和纵轴刻度
  ctx.beginPath();
  ctx.lineWidth = 2;
  ctx.textBaseline = "middle";

  for (let i = 0; i < canvas.height / rectH; i++) {
    // 绘制纵轴刻度
    ctx.moveTo(0, i * rectH);
    ctx.lineTo(tickLength, i * rectH);
    ctx.font = "20px Arial";
    ctx.fillText(i, -25, i * rectH);
  }
  for (let i = 1; i < canvas.width / rectW; i++) {
    // 绘制横轴刻度
    ctx.moveTo(i * rectW, 0);
    ctx.lineTo(i * rectW, tickLength);
    ctx.font = "20px Arial";
    ctx.fillText(i, i * rectW - 5, -15);
  }
  ctx.stroke();

  ctx.restore();
};

const renderScene = (canvas) => {
  const context = canvas.getContext("2d");
  drawAxis(context);
};

export default renderScene;
```

然后在 index.jsx 中引入 renderScene

```jsx
useEffect(() => {
  //...
  renderScene(canvas);
}, []);
```

效果如下：

![image](../../excalidraw-app/infinite-01.jpg)

## 绘制矩形

### 屏幕坐标系转 canvas 坐标系

在开始绘制矩形之前，我们先来看下屏幕坐标系如何转换成 canvas 坐标系。如下图所示，对于 canvas 上的任意一点，比如下面的 A 点。当我们点击事件位于 A 点时，我们可以获取到 A 点的屏幕坐标 `(event.clientX, event.clientY)`。那么 A 点的 canvas 坐标计算方式就是

```js
x = event.clientX - canvas.offsetLeft;
y = event.clientY - canvas.offsetTop;
```

![image](../../excalidraw-app/infinite-02.png)

因此我们可以封装一个坐标系转换的工具方法`viewportCoordsToSceneCoords`

```js
const viewportCoordsToSceneCoords = (
  { clientX, clientY },
  { offsetLeft, offsetTop }
) => {
  const x = clientX - offsetLeft;
  const y = clientY - offsetTop;
  return { x, y };
};
```
